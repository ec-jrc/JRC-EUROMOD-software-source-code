using EM_Common;
using EM_Transformer;
using EM_XmlHandler;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace InDepthAnalysis
{
    internal class SystemInfo
    {
        internal const string ILS_ORIGY = "ils_origy";
        internal const string ILS_DISPY = "ils_dispy";
        internal const string ILS_EARNS = "ils_earns";
        internal const string ILS_TAX = "ils_tax";
        internal const string ILS_SICDY = "ils_sicdy";
        internal const string ILS_SICER = "ils_sicer";
        internal const string ILS_SICCT = "ils_sicct";
        internal const string ILS_SICDYERCT = "ils_sic";
        internal const string ILS_PEN = "ils_pen";
        internal const string ILS_BEN = "ils_ben";
        internal const string ILS_BENMT = "ils_benmt";
        internal const string ILS_BENNT = "ils_bennt";
        internal static string[] ILS_SICDYERCT_LIST = new string[] { ILS_SICDY, ILS_SICER, ILS_SICCT };

    internal List<string> contentFile = new List<string>();
        internal List<ModGenVarInfo> modGenVarInfos = new List<ModGenVarInfo>();

        internal string systemName = null;

        internal Dictionary<string, Dictionary<string, IlVarInfo>> fiscalIls = new Dictionary<string, Dictionary<string, IlVarInfo>>(StringComparer.OrdinalIgnoreCase)
        {
            { ILS_EARNS, new Dictionary<string, IlVarInfo>(StringComparer.OrdinalIgnoreCase) }, 
            { ILS_TAX, new Dictionary<string, IlVarInfo>(StringComparer.OrdinalIgnoreCase) }, 
            { ILS_SICDY, new Dictionary<string, IlVarInfo>(StringComparer.OrdinalIgnoreCase) }, 
            { ILS_SICER, new Dictionary<string, IlVarInfo>(StringComparer.OrdinalIgnoreCase) }, 
            { ILS_SICCT, new Dictionary<string, IlVarInfo>(StringComparer.OrdinalIgnoreCase) }, 
            { ILS_PEN, new Dictionary<string, IlVarInfo>(StringComparer.OrdinalIgnoreCase) }, 
            { ILS_BENMT, new Dictionary<string, IlVarInfo>(StringComparer.OrdinalIgnoreCase) }, 
            { ILS_BENNT, new Dictionary<string, IlVarInfo>(StringComparer.OrdinalIgnoreCase) }
        };

        internal class IlVarInfo
        {
            internal string description = string.Empty;
            internal bool substract = false;
        }

        internal class ModGenVarInfo
        {
            internal string name = string.Empty;
            internal bool isMonetary = true, isConstant = false, isIL = false;
        }

        internal static SystemInfo Get(Settings settings, string outputFilePath, out string warnings)
        {
            warnings = string.Empty;
            try
            {
                SystemInfo systemInfo = new SystemInfo(); RunLogger.RunInfo runInfo = null;
                if (File.Exists(outputFilePath))
                {
                    // get the variables contained in the output-file
                    foreach (string variable in File.ReadLines(outputFilePath).First().Split('\t').Distinct(StringComparer.OrdinalIgnoreCase).ToList())
                        systemInfo.contentFile.Add(variable);

                    // get system-name from run-log, if run-log exists
                    if (RunLogger.GetRunInfo(outputFilePath, out runInfo, out RunLogger.GeneralInfo generalInfo))
                    {
                        string project = new DirectoryInfo(settings.pathEuromodFiles)?.Name;
                        if (!string.IsNullOrEmpty(project) && generalInfo.project.ToLower() != project.ToLower())
                            warnings += $"{outputFilePath} was generated by project '{generalInfo.project}'. Thus it is possible that variables do not coincide with settings in project '{project}'." + Environment.NewLine + Environment.NewLine;
                        systemInfo.systemName = runInfo.systemName;
                    }
                }
                if (systemInfo.systemName == null)
                    systemInfo.systemName = Path.GetFileName(outputFilePath).Replace(".txt", string.Empty).Replace("_std", string.Empty); // note: should be maybe inside 'if (brf.exists)': like it is now: retrieve info of an existing system without existing output-file(?)

                if (!GetCountryShortName(systemInfo, out string countryShortName)) throw new Exception("failed to deduce country short name.");

                EMPath emPath = new EMPath(settings.pathEuromodFiles);

                if (!File.Exists(emPath.GetCountryFilePath(countryShortName, true)))
                    throw new Exception($"system info cannot be retrieved: country file {emPath.GetCountryFilePath(countryShortName, true)} does not exist.");

                if (countryShortName != null)
                {
                    if (!EM3Country.Transform(settings.pathEuromodFiles, countryShortName, out List<string> errors))
                        throw new Exception($"transforming to EM3 failed: {string.Join(";", errors)}");
                    string w = string.Empty; Communicator communicator = new Communicator()
                    {
                        errorAction = new Action<Communicator.ErrorInfo>
                        (ei => { w += $"{Path.GetFileName(outputFilePath)}: {ei.message}" + Environment.NewLine; })
                    };
                    ExeXml.Country countryContent = ExeXmlReader.ReadCountry(emPath.GetCountryFilePath(countryShortName),
                                                    systemInfo.systemName, null, // null for dataIdentifier
                                                    false, communicator, true); // false for 'ignorePrivate', true for 'readComment'
                    if (communicator.errorCount > 0) throw new Exception("reading country failed: " + w);
                    if (w != string.Empty) warnings += w + Environment.NewLine + Environment.NewLine;

                    HandleExtensionSwitches(countryContent, runInfo, emPath);

                    // analyse the country file's functions to get the for our purposes required information
                    AnalyseCountryFile(countryContent,
                        out Dictionary<string, Dictionary<string, IlVarInfo>> contentILs, // not (yet) flat content of incomelists; key: incomelist-name, value: incomelist-content: names + factors of variables/incomelists
                        out systemInfo.modGenVarInfos);


                    foreach (string key in systemInfo.fiscalIls.Keys)
                    {
                        // if this is "ils_sic" use the hard-coded list here! 
                        if (key.Equals(ILS_SICDYERCT))
                        foreach (string k in ILS_SICDYERCT_LIST)
                                GetContentIL(k, systemInfo.fiscalIls[key]);
                        // else, return the incomelist
                        GetContentIL(key, systemInfo.fiscalIls[key]);
                    }

                    void GetContentIL(string ilNames, Dictionary<string, IlVarInfo> contentIL)
                    {
                        foreach (string ilName in ilNames.Split(','))
                        {
                            if (!contentILs.ContainsKey(ilName)) return;
                            foreach (var v in GetFlatIl(contentILs[ilName]))
                            {
                                string varName = v.Key; IlVarInfo varInfo = v.Value;
                                if (!contentIL.ContainsKey(varName))
                                    contentIL.Add(varName, new IlVarInfo() { description = varInfo.description, substract = varInfo.substract });
                                else throw new Exception($"Duplicate variable '{varName}' found in income list: {ilName}");
                            }
                        }
                    }

                    Dictionary<string, IlVarInfo> GetFlatIl(Dictionary<string, IlVarInfo> il, bool substract = false)
                    {
                        Dictionary<string, IlVarInfo> flatIl = new Dictionary<string, IlVarInfo>();
                        foreach (var entry in il)
                        {
                            string entryName = entry.Key; IlVarInfo entryVarInfo = entry.Value; entryVarInfo.substract ^= substract;
                            if (!contentILs.ContainsKey(entryName)) // variable
                            {
                                if (!flatIl.ContainsKey(entryName)) flatIl.Add(entryName, entryVarInfo);
                            }
                            else // another incomelist
                            {
                                foreach (var subIlEntry in GetFlatIl(contentILs[entryName], entryVarInfo.substract))
                                {
                                    string subIlEntryName = subIlEntry.Key; IlVarInfo subILEntryVarInfo = subIlEntry.Value;
                                    if (!flatIl.ContainsKey(subIlEntryName)) flatIl.Add(subIlEntryName, subILEntryVarInfo);
                                }
                            }
                        }
                        return flatIl;
                    }
                }
                return systemInfo;
            }
            catch (Exception exception)
            {
                warnings += $"Failed to retrieve system info for {outputFilePath}: " + exception.Message + Environment.NewLine + Environment.NewLine;
                return null;
            }
        }

        private static void HandleExtensionSwitches(ExeXml.Country countryContent, RunLogger.RunInfo runInfo, EMPath emPath)
        {
            try
            {
                Dictionary<string, bool> runConfigSwitches = runConfigSwitches = new Dictionary<string, bool>();
                if (runInfo != null)
                {
                    foreach (var sw in runInfo.extensionSwitches)
                    {
                        string id = EM_ExtensionSwitchHandler.GetExtensionIdByName(sw.Key, countryContent, emPath, new Communicator());
                        if (id != null) runConfigSwitches.Add(id, sw.Value == DefPar.Value.ON);
                    }
                }
                EM_ExtensionSwitchHandler.ApplySwitches(countryContent, runConfigSwitches);
            }
            catch { } // do not jeopardise the programme because switch handling did not work
        }

        private static void AnalyseCountryFile(ExeXml.Country countryContent, out Dictionary<string, Dictionary<string, IlVarInfo>> contentILs,
                                                                              out List<ModGenVarInfo> modGenVarInfos)
        {
            Dictionary<string, Dictionary<string, IlVarInfo>> _contentILs = new Dictionary<string, Dictionary<string, IlVarInfo>>(StringComparer.OrdinalIgnoreCase);
            List<ModGenVarInfo> _modGenVarInfos = new List<ModGenVarInfo>();

            foreach (ExeXml.Pol pol in countryContent.cao.pols.Values)
            {
                if (!pol.on) continue;
                foreach (var fun in pol.funs.Values)
                {
                    if (!fun.on) continue;
                    if (fun.Name.ToLower() == DefFun.DefIl.ToLower()) AnalyseDefIL(fun);
                    else if (fun.Name.ToLower() == DefFun.DefVar.ToLower()) AnalyseDefVar(fun, false);
                    else if (fun.Name.ToLower() == DefFun.DefConst.ToLower()) AnalyseDefVar(fun, true);
                }
            }
            contentILs = _contentILs; modGenVarInfos = _modGenVarInfos;

            void AnalyseDefIL(ExeXml.Fun fun)
            {
                string ilName = null; Dictionary<string, IlVarInfo> content = new Dictionary<string, IlVarInfo>(StringComparer.OrdinalIgnoreCase);
                foreach (var par in fun.pars.Values)
                {
                    if (par.Name.ToLower() == DefPar.DefIl.Name.ToLower()) ilName = par.val;
                    else if (!GetNamedParList(fun.Name).Contains(par.Name, true))
                        content.Add(par.Name, new IlVarInfo() { description = par.comment ?? string.Empty, substract = FactorToSubstract(par.val) });
                }
                if (ilName == null || _contentILs.ContainsKey(ilName)) return;
                _contentILs.Add(ilName, content);
                _modGenVarInfos.Add(new ModGenVarInfo() { name = ilName, isIL = true });

                bool FactorToSubstract(string parVal)
                {
                    double factor = double.NaN; parVal = parVal.Trim();
                    if (parVal == "+") return false;
                    else if (parVal == "-") return true;
                    else
                    {
                        if (parVal.StartsWith("+")) parVal = parVal.Substring(1);
                        if (double.TryParse(parVal, out double d)) factor = d;
                    }
                    return factor < 0;
                }
            }

            void AnalyseDefVar(ExeXml.Fun fun, bool isConst)
            {
                Dictionary<string, string> varAndGroup = new Dictionary<string, string>();
                List<string> groupsNonMonVars = new List<string>();
                foreach (var par in fun.pars.Values) // just assess whether variables are monetary and ignore other complexities (dataset, systemyear, condition) for simplicity
                {
                    if (!GetNamedParList(fun.Name).Contains(par.Name, true)) varAndGroup.TryAdd(par.Group, par.Name);
                    else if (par.Name.ToLower() == DefPar.DefVar.Var_Monetary.ToLower() && par.val.ToLower() == DefPar.Value.NO)
                        groupsNonMonVars.Add(par.Group);
                }
                foreach (var v in varAndGroup)
                    if (!(from m in _modGenVarInfos where m.name.ToLower() == v.Value.ToLower() select m).Any())
                        _modGenVarInfos.Add(new ModGenVarInfo() { name = v.Value, isConstant = isConst,
                                                                  isMonetary = !isConst && !groupsNonMonVars.Contains(v.Key, true) });
            }

            List<string> GetNamedParList(string funName)
            {
                List<string> namedParList = DefinitionAdmin.GetFunDefinition(funName, false).GetParList().Keys.ToList();
                foreach (Dictionary<string, DefinitionAdmin.Par> parList in from g in DefinitionAdmin.GetFunDefinition(funName, false).GetGroupParList() select g.par)
                    namedParList.AddRange(from p in parList select p.Key);
                return namedParList;
            }
        }

        internal static bool GetCountryShortName(SystemInfo systemInfo, out string countryShortName)
        {
            countryShortName = string.Empty; if (!systemInfo.systemName.Contains('_')) return false;
            countryShortName = systemInfo.systemName.Split('_').First(); return true;
        }

        internal Dictionary<string, IlVarInfo> GetIncomelistContent(string ilName)
        {
            if (fiscalIls.ContainsKey(ilName)) return fiscalIls[ilName];
            throw new Exception($"Programm error: unknown incomelist {ilName}");
        }
    }
}
