using System;
using System.Collections.Generic;

namespace EM_Common
{
    public partial class DefinitionAdmin
    {
        private static string GetFunDescription(string fun) { return funParQueryDesc.GetOrEmpty(fun); }
        private static string GetParDescription(string fun, string par)
        {
            string d = funParQueryDesc.GetOrEmpty(fun + "|" + par);
            if (d == string.Empty) d = funParQueryDesc.GetOrEmpty("QUERY|" + par);
            return d;
        }
        private static string GetQueryDescription(string query) { return funParQueryDesc.GetOrEmpty(query); }
        private static string GetQueryParDescription(string par) { return funParQueryDesc.GetOrEmpty("QUERY|" + par); }

        // this dictionary was generated by extracting from FuncConfig (see FuncConfigEditor ExtractDescriptions.cs)
        // any new descriptions are directly put into the parameter definitions (DefPar folder)
        private static Dictionary<string, string> funParQueryDesc = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "QUERY|"+DefQuery.Par.Income, "Parameter of several queries (e.g. GetPartnerIncome)." },
            { DefFun.BenCalc+"|"+DefPar.BenCalc.Comp_perElig, "Formula to calculate one component of the function's result. The result of the formula is added to the function's result once for each member of the assessment unit fulfiling the components condition (Comp_Cond).\nSyntax rules as for parameter Formula of function ArithOp apply." },
            { DefFun.SchedCalc+"|"+DefPar.SchedCalc.Base, "Base income for the schedule." },
            { DefFun.SchedCalc+"|"+DefPar.SchedCalc.Band_UpLim, "Upper limit of band." },
            { DefFun.SchedCalc+"|"+DefPar.SchedCalc.Band_LowLim, "Lower limit of band." },
            { DefFun.SchedCalc+"|"+DefPar.SchedCalc.Band_Rate, "Rate to apply on band." },
            { DefFun.SchedCalc+"|"+DefPar.SchedCalc.Band_Amount, "Amount to add for band." },
            { DefFun.SchedCalc+"|"+DefPar.SchedCalc.Do_Average_Rates, "If set to yes the rate of the highest band reached by Base is applied on the total amout of Base." },
            { DefFun.SchedCalc+"|"+DefPar.SchedCalc.Quotient, "If defined Base is divided by the quotient before the schedule is applied. Afterwards the result is multiplied by the quotient." },
            { DefFun.SchedCalc+"|"+DefPar.SchedCalc.BaseThreshold, "If Base is smaller result is set to zero." },
            { DefFun.SchedCalc+"|"+DefPar.SchedCalc.Round_Base, "If defined Base is rounded to nearest whole number if set to 1, to nearest number with 1 decimal if set to 0.1, to nearest 10 if set to 10, etc." },
            { DefFun.SchedCalc+"|"+DefPar.SchedCalc.Simple_Prog, "If set to yes the same rate/amount is applied on all income. The respective rate/amount is the one of the highest band the income falls into." },
            { DefFun.Allocate+"|"+DefPar.Allocate.Share, "Amount to be (re)allocated between assessment unit members." },
            { DefFun.Allocate+"|"+DefPar.Allocate.Share_Between, "Condition that must be fulfilled by a member of the assessment unit to be among the persons between who the amount is (re)allocated.\nSyntax rules as for parameter Elig_Cond of function Elig apply." },
            { DefFun.Allocate+"|"+DefPar.Allocate.Share_All_IfNoElig, "If no member of the assessment unit fulfils the condition defined by Share_Between:\n- if set to yes: amount is equally (re)allocated among members of the assessment unit.\n- if set to no: Output_Var is set to zero (respectively zero is added to Output_Add_Var)." },
            { DefFun.Allocate+"|"+DefPar.Allocate.Share_Prop, "If the parameter is defined, (re)allocation is carried out in proportion to this variable/incomelist." },
            { DefFun.Allocate+"|"+DefPar.Allocate.Share_Equ_IfZero, "If the variable/incomelist defined by Share_Prop is zero for all members of the assessment unit (who fulfil Share_Between):\n- if set to no: an error message is issued.\n- if set to yes: amount is equally (re)allocated among all members of the assessment unit (who fulfil Share_Between)." },
            { DefFun.Allocate+"|"+DefPar.Allocate.Ignore_Neg_Prop, "If the variable/incomelist defined by Share_Prop is negative it is ignored (i.e.  it is considered to be zero)." },
            { DefFun.DefConst+"|"+DefPar.DefConst.Const_Dataset, "If set, constants are only defined if the respective dataset is used for the run." },
            { DefFun.DefConst+"|"+DefPar.DefConst.Const_SystemYear, "If set, constants are only defined if the run concerns the respective system year." },
            { DefFun.DefConst+"|"+DefPar.PAR_TYPE.PLACEHOLDER, "[Placeholder] stands for the name of the constant, which is defined in the policy column. The value of the constant is defined in the (respective) system column (i.e. may be system specific).\nNote that the value of the constant can also be (re)defined by e.g. ArithOp, but it must not be household or person specific (i.e. as a constant it must be equal for each individual)." },
            { DefFun.DefConst+"|"+DefPar.DefConst.Condition, "If set, constant with same group only takes this value if condition is fulfilled (i.e. allows for different values based on conditions). Note that a conditioned constant cannot be used as global value (e.g. in Run_Cond)." },
            { DefFun.DefVar+"|"+DefPar.DefVar.Var_Dataset, "If set, variables are only defined if the respective dataset is used for the run." },
            { DefFun.DefVar+"|"+DefPar.DefVar.Var_SystemYear, "If set, variables are only defined if the run concerns the respective system year." },
            { DefFun.DefVar+"|"+DefPar.DefVar.Var_Monetary, "If set to no: variable with same group is treated as a non-monetary variable, otherwise as a monetary variable." },
            { DefFun.DefVar+"|"+DefPar.PAR_TYPE.PLACEHOLDER, "[Placeholder] stands for the name of the variable, which is defined in the policy column. Optionally a (constant) initial value can be defined in the (respective) system column (i.e. may be system specific).\nAfter its definition the variable can (apart from minor specifics) be used in the same way as regular variables." },
            { DefFun.DefIl+"|"+DefPar.DefIl.Name, "Name of the incomelist." },
            { DefFun.DefIl+"|"+DefPar.PAR_TYPE.PLACEHOLDER, "[Placeholder] stands for the name of a component (variable or incomelist) of the incomelist, which is defined in the policy column. A plus (+) in the respective system's column means that the component is added. A minus (-) indicates that the component is subtracted." },
            { DefFun.DefIl+"|"+DefPar.DefIl.Warn_If_NonMonetary, "If yes, a warning is issued if any component is non-monetary." },
            { DefFun.DefTu+"|"+DefPar.DefTu.Type, "Indicates the scope of the assessment unit.\nPossible values:\n- HH: all members of the household belong to one unit.\n- IND: each members of the household forms an own unit.\n- SUBGROUP: unit members are specified as indicated in the parameter Members." },
            { DefFun.DefTu+"|"+DefPar.DefTu.Name, "Name of the assessment unit." },
            { DefFun.DefTu+"|"+DefPar.DefTu.Members, "Specifies which members of the household form a unit, if parameter Type is set to SOUBGROUP.\nSyntax: Status & Status & Status & ..., e.g. Partner & OwnChild.\n\nPossible values for Status:\n- Partner: defined by parameter PartnerCond\n- OwnDepChild: defined by parameter OwnDepChildCond\n- LooseDepChild: defined by parameter LooseDepChildCond\n\n- OwnChild: defined by parameter OwnChildCond\n- DepParent: defined by parameter DepParentCond\n- DepRelative: defined by parameter DepRelativeCond\n\nNote, that the Head is obviously always part of unit and (usually) relations are defined with reference to the Head." },
            { DefFun.DefTu+"|"+DefPar.DefTu.HeadDefInc, "Incomelist used for determining who is the richest person in the assessment unit, see parameter ExtHeadCond." },
            { DefFun.DefTu+"|"+DefPar.DefTu.ExtHeadCond, "Condition further defining the head of the assessment unit. The condition is &-linked with the following fixed head condition:\n{HeadDefInc>anyother:HeadDefInc} | \n({HeadDefInc>=anyother:HeadDefInc} & {dag>anyother:dag}) | \n({HeadDefInc>=anyother:HeadDefInc} & {dag>=anyother:dag} & {idperson<anyother:idperson})" },
            { DefFun.DefTu+"|"+DefPar.DefTu.PartnerCond, "Condition defining who is a partner." },
            { DefFun.DefTu+"|"+DefPar.DefTu.DepChildCond, "Condition defining who is a dependent child.\nThe 'real' default, i.e. if the parameter is not defined or set to n/a, is {0} (i.e. nobody is a child).\nHowever, setting the parameter to '{Default}' is interpreted as !{isparent}&{idpartner<=0}." },
            { DefFun.DefTu+"|"+DefPar.DefTu.OwnChildCond, "Condition defining who is an own child." },
            { DefFun.DefTu+"|"+DefPar.DefTu.OwnDepChildCond, "Condition defining who is an own dependent child." },
            { DefFun.DefTu+"|"+DefPar.DefTu.LooseDepChildCond, "Condition defining who is a loose dependent child." },
            { DefFun.DefTu+"|"+DefPar.DefTu.DepParentCond, "Condition defining who is a dependent parent." },
            { DefFun.DefTu+"|"+DefPar.DefTu.DepRelativeCond, "Condition defining who is a dependent relative." },
            { DefFun.DefTu+"|"+DefPar.DefTu.LoneParentCond, "Condition defining who is a lone parent." },
            { DefFun.DefTu+"|"+DefPar.DefTu.StopIfNoHeadFound, "If set to yes: an error is issued if ExtHeadCond rules out all household members.\nIf se to no: no error issued, instead ExtHeadCond is dropped for affected households." },
            { DefFun.DefTu+"|"+DefPar.DefTu.NoChildIfHead, "If set to yes (possible) child status is removed if person is the Head of the assessment unit." },
            { DefFun.DefTu+"|"+DefPar.DefTu.NoChildIfPartner, "If set to yes (possible) child status is removed if person is Partner as defined by parameter PartnerCond." },
            { DefFun.DefTu+"|"+DefPar.DefTu.AssignDepChOfDependents, "If set to yes dependent children of dependent unit members (i.e. persons who are not Head or Partner of the unit) are assigned to the unit." },
            { DefFun.DefTu+"|"+DefPar.DefTu.AssignPartnerOfDependents, "If set to yes partners of dependent unit members (i.e. persons who are not Head or Partner of the unit) are assigned to the unit." },
            { DefFun.Uprate+"|"+DefPar.Uprate.Dataset, "Name of a dataset(s) for which the uprating settings apply.\nIf the settings apply for several datasets, the parameter can be used more than once. Moreover, the wildcards * and ? can be used, where * stands for any character and ? stands for one arbitrary character (e.g. be_20*_v?)." },
            { DefFun.Uprate+"|"+DefPar.Uprate.Def_Factor, "Factor, which is applied on all monetary variables in the dataset, which do not have a particular own factor.\nPossible values are amounts (e.g. 1.023) or factors as defined by parameters Factor_Name, Factor_Value, Factor_Condition." },
            { DefFun.Uprate+"|"+DefPar.Uprate.Factor_Name, "Name of a specific uprating factor, whose value is specified by parameter Factor_Value." },
            { DefFun.Uprate+"|"+DefPar.Uprate.Factor_Value, "Value of a specific uprating factor.\nIf no name is specified via Factor_Name, the factor can be addressed as factorX, where X refers to the number in the Grp/No column." },
            { DefFun.Uprate+"|"+DefPar.PAR_TYPE.PLACEHOLDER, "[Placeholder] stands for the name of a variable, defined in the policy column, whose uprating factors are specified in the respective system columns.\nThe uprating factors can be indicated as amounts (e.g. 1.023) or factors, as defined by parameters Factor_Name, Factor_Value, Factor_Condition." },
            { DefFun.Uprate+"|"+DefPar.Uprate.Factor_Condition, "Condition that needs to be fulfilled to apply the factor specified by parameters Factor_Value and (optionally) Factor_Name." },
            { DefFun.Uprate+"|"+DefPar.Uprate.AggVar_Name, "Name of an aggregate variable (e.g. yse)." },
            { DefFun.Uprate+"|"+DefPar.Uprate.AggVar_Part, "Name of a component variable of the aggregate variable defined by AggVar_Name (e.g. ysebs)." },
            { DefFun.Uprate+"|"+DefPar.Uprate.AggVar_Tolerance, "If the value of the variable specified by parameter AggVar_Name differs from the sum of its components defined by parameters AggVar_Part, an error message is issued, but only if the absolute difference is higher than aggvarX_tolerance." },
            { DefFun.Uprate+"|"+DefPar.Uprate.WarnIfNoFactor, "If set to yes an warning is issued for any monetary dataset variable without an explicitly defined uprating factor." },
            { DefFun.Uprate+"|"+DefPar.Uprate.RegExp_Def, "Pattern (regular expression) defining the group of variables to be uprated by RegExp_Factor, e.g. x[0-9]+." },
            { DefFun.Uprate+"|"+DefPar.Uprate.RegExp_Factor, "Factor by which the variables defined by RegExp_Def are uprated." },
            { DefFun.Uprate+"|"+DefPar.Uprate.WarnIfNonMonetary, "If set to yes, a warning is issues for uprating non-monetary variables." },
            { DefFun.SetDefault+"|"+DefPar.SetDefault.Dataset, "Name of a dataset(s) for which the default settings apply.\nIf the settings apply for several datasets, the parameter can be used more than once. Moreover, the wildcards * and ? can be used, where * stands for any character and ? stands for one arbitrary character (e.g. be_20*_v?)." },
            { DefFun.SetDefault+"|"+DefPar.PAR_TYPE.PLACEHOLDER, "[Placeholder] stands for the name of a variable, defined in the policy column, whose default values are specified in the respective system columns (i.e. the default may be system specific)." },
            { DefFun.Min +"|"+DefPar.Min .Val, "Values for which the minimum should be calculated." },
            { DefFun.Min +"|"+DefPar.Min .Positive_Only, "If set to yes, negative and zero-values are ignored.\nIf there is no positive value the result is 0." },
            { DefFun.Max+"|"+DefPar.Max.Val, "Values for which the maximum should be calculated." },
            { DefFun.UpdateTu+"|"+DefPar.UpdateTu.Name, "Name of the assessment unit." },
            { DefFun.UpdateTu+"|"+DefPar.UpdateTu.Update_All, "If set to yes all assessment units are updated." },
            { DefFun.ChangeParam+"|"+DefPar.ChangeParam.Param_Id, "Identifier for the parameter to change or the policy/function whose switch to change.\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.ChangeParam+"|"+DefPar.ChangeParam.Param_NewVal, "New value for parameter to be exchanged at read time." },
            { DefFun.ChangeParam+"|"+DefPar.ChangeParam.Param_CondVal, "New value for parameter to be exchanged at run time (i.e. when the programme run reaches the respective ChangeParam function)." },
            { DefFun.Loop+"|"+DefPar.Loop.Last_Pol, "Name of loop's last policy." },
            { DefFun.Loop+"|"+DefPar.Loop.Last_Func, "Identifier of loop's last function.\nThe identifier cannot refer to functions which are independent of the policy spine (func_loop, func_unitloop, etc.).\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.Loop+"|"+DefPar.Loop.Stop_Before_Pol, "Name of the policy before which the loop ends." },
            { DefFun.Loop+"|"+DefPar.Loop.Stop_Before_Func, "Identifier of the function before which the loop ends.\nThe identifier cannot refer to functions which are independent of the policy spine (func_loop, func_unitloop, etc.).\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.Loop+"|"+DefPar.Loop.First_Pol, "Name of loop's first policy." },
            { DefFun.Loop+"|"+DefPar.Loop.First_Func, "Identifier of loop's first function.\nThe identifier cannot refer to functions which are independent of the policy spine (func_loop, func_unitloop, etc.).\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.Loop+"|"+DefPar.Loop.Start_After_Pol, "Name of the policy after which the loop starts." },
            { DefFun.Loop+"|"+DefPar.Loop.Start_After_Func, "Identifier of the function after which the loop starts.\nThe identifier cannot refer to functions which are independent of the policy spine (func_loop, func_unitloop, etc.).\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.Loop+"|"+DefPar.Loop.Loop_Id, "Unique identifier for the loop.\nThe identifier is used amongst others for constructing the name of the loop count variable 'LoopCount_Loop_Id'." },
            { DefFun.Loop+"|"+DefPar.Loop.Num_Iterations, "Number of loop iterations." },
            { DefFun.Loop+"|"+DefPar.Loop.BreakCond, "Break condition checked at the end of the loop.\nThe condition must not contain household/individual specific operators." },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.Last_Pol, "Name of loop's last policy." },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.Last_Func, "Identifier of loop's last function.\nThe identifier cannot refer to functions which are independent of the policy spine (func_loop, func_unitloop, etc.).\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.Stop_Before_Pol, "Name of the policy before which the loop ends." },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.Stop_Before_Func, "Identifier of the function before which the loop ends.\nThe identifier cannot refer to functions which are independent of the policy spine (func_loop, func_unitloop, etc.).\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.First_Pol, "Name of loop's first policy." },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.First_Func, "Identifier of loop's first function.\nThe identifier cannot refer to functions which are independent of the policy spine (func_loop, func_unitloop, etc.).\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.Start_After_Pol, "Name of the policy after which the loop starts." },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.Start_After_Func, "Identifier of the function after which the loop starts.\nThe identifier cannot refer to functions which are independent of the policy spine (func_loop, func_unitloop, etc.).\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.Loop_Id, "Unique identifier for the loop.\nThe identifier is used amongst others for constructing the name of the loop count variable 'LoopCount_Loop_Id'." },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.Elig_Unit, "Calculations are repeated for each Elig_Unit within the household." },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.Elig_Unit_Cond, "Calculations are only carried out for Elig_Units, which are fulfil this condition." },
            { DefFun.UnitLoop+"|"+DefPar.UnitLoop.Elig_Unit_Cond_Who, "Defines which members of the unit must fulfil Elig_Unit_Cond to make the unit fulfil the condition.\nFor possible values see the common parameter Who_Must_Be_Elig." },
            { DefFun.Store+"|"+DefPar.Store.PostLoop, "Copies of stored variables are called VarName_PostLoopIteration.\nFor example: Var = yem, PostLoop = myloop: name of copies = yem_myloop1 (1. iteration), yem_myloop2 (2. iteration), etc." },
            { DefFun.Store+"|"+DefPar.Store.PostFix, "Copies of stored variables are called VarName_PostFix.\nFor example: Var = yem, PostFix = bkup: name of copy = yem_bkup." },
            { DefFun.Store+"|"+DefPar.Store.Var, "Name of a variable to be stored." },
            { DefFun.Store+"|"+DefPar.Store.Var_Level, "Alternative assessment unit: variable's value is assessed based on this unit.\nNote that the parameter is only relevant if PostLoop refers to a UnitLoop." },
            { DefFun.Store+"|"+DefPar.Store.IL, "Incomelist whose entries (i.e. variables) are to be stored." },
            { DefFun.Store+"|"+DefPar.Store.IL_Level, "Alternative assessment unit: the value of the variables included in IL is assessed based on this unit.\nNote that the parameter is only relevant if PostLoop refers to a UnitLoop." },
            { DefFun.Store+"|"+DefPar.Store.Level, "Alternative assessment unit: the value of all variables is assessed based on this unit, except for those which have a specific own Var_Level/IL_Level.\nNote that the parameter is only relevant if PostLoop refers to a UnitLoop." },
            { DefFun.Restore+"|"+DefPar.Restore.PostLoop, "copy of stored variable is called varname_postfix\ne.g. var1 = yem, postfix = bkup: name of copy = yem_bkup" },
            { DefFun.Restore+"|"+DefPar.Restore.PostFix, "copy of stored variable is called varname_postloopiteration\ne.g. var1 = yem, postloop = lp: name of copies = yem_lp1 (1. iteration), yem_lp2 (2. iteration), etc." },
            { DefFun.Restore+"|"+DefPar.Restore.Iteration, "to be used with parameter postloop: variables are set back to the value they had when function store was carried out in the indicated iteration" },
            { DefFun.DropUnit+"|"+DefPar.DropUnit.Drop_Cond, "Condition defining which assessment units (i.e. indvidual, families or households) are to be dropped." },
            { DefFun.DropUnit+"|"+DefPar.DropUnit.Drop_Cond_Who, "Defines which members of the assessment unit must fulfil Drop_Cond to make the unit fulfil the condition.\nFor possible values see the common parameter Who_Must_Be_Elig." },
            { DefFun.KeepUnit+"|"+DefPar.KeepUnit.Keep_Cond, "Condition defining which assessment units (i.e. indvidual, families or households) are to be  kept." },
            { DefFun.KeepUnit+"|"+DefPar.KeepUnit.Keep_Cond_Who, "Defines which members of the assessment unit must fulfil Keep_Cond to make the unit fulfil the condition.\nFor possible values see the common parameter Who_Must_Be_Elig." },
            { DefFun.IlVarOp+"|"+DefPar.IlVarOp.Operand, "Variables of Operator_IL are multiplied/increased by operand.\nExample: \nOperator_IL = ils_earns = { yem / yse } \nOperand = 2.5 \nAll other parameters are set to their defaults. \nResult: yem = yem * 2.5, yse = yse * 2.5" },
            { DefFun.IlVarOp+"|"+DefPar.IlVarOp.Operand_Factors, "Variables of Operator_IL are multiplied/increased by factors of Operator_IL.\nExample: \nOperator_IL = ils_earns_mul = { 3 yem / -2 yse } \nOperand_Factors = yes \nAll other parameters are set to their defaults. \nResult: yem = yem * 3, yse = yse * (-2)\n" },
            { DefFun.IlVarOp+"|"+DefPar.IlVarOp.Operand_IL, "Variables of Operator_IL are multiplied/increased by variables of Operand_IL.\nExample: \nOperator_IL = ils_earns = { yem / yse } \nOperand_IL = il_multiply = { poa / yiy } \nAll other parameters are set to their defaults. \nResult: yem = yem * poa, yse = yse * yiy\n" },
            { DefFun.IlVarOp+"|"+DefPar.IlVarOp.Operator_IL, "Incomelist containing the variables on which the operation takes place." },
            { DefFun.IlVarOp+"|"+DefPar.IlVarOp.Operation, "Possible values:\n- MUL: variables of Operator_IL are multiplied by Operand.\n- ADD: variables of Operator_IL are increased by Operand.\n- NEGTOZERO: negative variables of Operator_IL are set zo zero, postive variables keep their value." },
            { DefFun.IlVarOp+"|"+DefPar.IlVarOp.Sel_Var, "Possible values:\nALL: operation takes place on all variables of Operator_IL.\nMAX: operation takes place on the highest variable of Operator_IL.\nMIN: operation takes place on the smallest variable of Operator_IL.\nMINPOS: operation takes place on the smallest positive variable of Operator_IL (no operation occurs, if there is no positive variable)." },
            { DefFun.Totals+"|"+DefPar.Totals.Varname_Sum, "Name for variable to store population sum of Agg_IL / Agg_Var.\n(e.g. if Varname_Sum = $sum and Agg_Var = yem: sum is stored in $sum_yem)" },
            { DefFun.Totals+"|"+DefPar.Totals.Varname_Mean, "Name for variable to store mean of Agg_IL / Agg_Var.\n(e.g. if Varname_Mean = $mean and Agg_Var = yem: mean is stored in $mean_yem)" },
            { DefFun.Totals+"|"+DefPar.Totals.Varname_Median, "Name for variable to store median of Agg_IL / Agg_Var.\n(e.g. if Varname_Median = $median and Agg_Var = yem: median is stored in $median_yem)" },
            { DefFun.Totals+"|"+DefPar.Totals.Varname_Decile, "Name for variable to store decile points of Agg_IL / Agg_Var.\n(e.g. if Varname_Decile = $dec and Agg_Var = yem: decile points are stored in $dec1_yem, ..., $dec9_yem)" },
            { DefFun.Totals+"|"+DefPar.Totals.Varname_Quintile, "Name for variable to store quintile points of Agg_IL / Agg_Var.\n(e.g. if Varname_Quintile = $quint and Agg_Var = yem: decile points are stored in $quint1_yem, ..., $quint4_yem)" },
            { DefFun.Totals+"|"+DefPar.Totals.Varname_Count, "Name for variable to store Agg_IL / Agg_Var's count of non-zero values.\n(e.g. if Varname_Count = $count and Agg_Var = yem: count is stored in $count_yem)" },
            { DefFun.Totals+"|"+DefPar.Totals.Varname_PosCount, "Name for variable to store Agg_IL / Agg_Var's count of positive values.\n(e.g. if Varname_PosCount = $poscnt and Agg_Var = yem, count is stored in $poscnt_yem)" },
            { DefFun.Totals+"|"+DefPar.Totals.Varname_NegCount, "Name for variable to store Agg_IL / Agg_Var's count of negative values.\n(e.g. if Varname_NegCount = $negcnt and Agg_Var = yem: count is stored in $negcnt_yem)" },
            { DefFun.Totals+"|"+DefPar.Totals.Varname_Min, "Name for variable to store smallest value of Agg_IL / Agg_Var.\n(e.g. if Varname_Min = $min and Agg_Var = yem: minimum is stored in $min_yem)" },
            { DefFun.Totals+"|"+DefPar.Totals.Varname_Max, "Name for variable to store largest value of Agg_IL / Agg_Var.\n(e.g. if Varname_Max = $max and Agg_Var = yem: maximum is stored in $max_yem)" },
            { DefFun.Totals+"|"+DefPar.Totals.Agg, "Incomelist for which to calculate aggregates." },
            { DefFun.Totals+"|"+DefPar.Totals.Incl_Cond, "Condition that must be fulfilled by the assessment unit, as defined by TAX_UNIT, to be taken into account by the statistic." },
            { DefFun.Totals+"|"+DefPar.Totals.Incl_Cond_Who, "Defines which members of the assessment unit must fulfil Incl_Cond to make the unit fulfil the condition.\nFor possible values see the common parameter Who_Must_Be_Elig." },
            { DefFun.Totals+"|"+DefPar.Totals.Use_Weights, "If set to yes weights are used to calculate the aggregates." },
            { DefFun.Totals+"|"+DefPar.Totals.Weight_Var, "Specifies an alternative weight variable." },
            { DefFun.RandSeed+"|"+DefPar.RandSeed.Seed, "Integer value as starting point for random number generation." },
            { DefFun.CallProgramme+"|"+DefPar.CallProgramme.Programme, "Name of the application to be called.\nExample: Excel.exe" },
            { DefFun.CallProgramme+"|"+DefPar.CallProgramme.Path, "Path to the application.\nDispensable if the application is  installed at the standard path for programmes.\nHowever, note that the path is also used as the working directory for the application.\nExample: C:\\Program Files\\Microsoft Office\\ \nNote that spaces can be used without encapsulating the path by '." },
            { DefFun.CallProgramme+"|"+DefPar.CallProgramme.Argument, "Programme argument to be passed to the application.\nExample: C:\\EuromodFiles\\Tools\\EMT_FillTemplate.xls (to e.g. open Excel with this workbook)" },
            { DefFun.CallProgramme+"|"+DefPar.CallProgramme.UnifySlash, "If set to yes all occurrences of / are replaced by \\ in parameters Path and Argument." },
            { DefFun.CallProgramme+"|"+DefPar.CallProgramme.Wait, "If set to yes: EUROMOD calculations are stopped until the called programme terminates.\nIf set to no: EUROMOD calculations continue without waiting." },
            { DefFun.CallProgramme+"|"+DefPar.CallProgramme.RepByEMPath, "Any occurrences of RepByEMPath in parameters Path, and Argument are replaced by the path of the current EUROMOD installation.\nExample: RepByEMPath = &, Argument = &Tools\\SomeFile.xls, EUROMOD is installed at C:\\EuromodFiles\\ \nResult: Argument is interpreted as C:\\EuromodFiles\\Tools\\SomeFile.xls.\n\nRemark: To assess the path of the current EUROMOD installation it is assumed that the files belonging to the EUROMOD bundle are installed in the standard configuration. Technically the programme assesses the path of the executable and assumes that the executable is located in the Executable folder, which itself is located is in the root of the EUROMOD installation. In other words the resulting folder is the folder, which is superordinate to the folder containing the executable." },
            { DefFun.AddOn_Applic+"|"+DefPar.AddOn_Applic.Description, "A short description of the add-on (amongst others to be displayed by the run-tool)." },
            { DefFun.AddOn_Applic+"|"+DefPar.AddOn_Applic.Sys, "Name of (a) system(s) for which the add-on is applicable.\nWildcards * and ? can be used, where * stands for any character and ? stands for one arbitrary character (e.g. *_200?)." },
            { DefFun.AddOn_Applic+"|"+DefPar.AddOn_Applic.SysNA, "Name of (a) system(s) for which the add-on is not applicable.\nNote that not applicability prevails over applicability (i.e. SysNA is stronger than Sys).\nWildcards * and ? can be used, where * stands for any character and ? stands for one arbitrary character (e.g. ??_2005)." },
            { DefFun.AddOn_Pol+"|"+DefPar.AddOn_Pol.Pol_Name, "Name of the policy to insert (must be unique)." },
            { DefFun.AddOn_Pol+"|"+DefPar.AddOn_Pol.Insert_Before_Pol, "Name of the policy before which the add-on policy should be inserted." },
            { DefFun.AddOn_Pol+"|"+DefPar.AddOn_Pol.Insert_After_Pol, "Name of the policy after which the add-on policy should be inserted." },
            { DefFun.AddOn_Pol+"|"+DefPar.AddOn_Pol.Allow_Duplicates, "If set to no: adding a policy twice (i.e. Pol_Name identical) leads to an error message.\nIf set to yes: adding a policy twice works, but 'references' cannot be used, i.e. the usage of functions like ChangeParam and Loop is not possible." },
            { DefFun.AddOn_Func+"|"+DefPar.AddOn_Func.Id_Func, "Identifier of the function to insert.\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.AddOn_Func+"|"+DefPar.AddOn_Func.Insert_Before_Func, "Identifier of the function before which the add-on function should be inserted.\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.AddOn_Func+"|"+DefPar.AddOn_Func.Insert_After_Func, "Identifier of the function after which the add-on function should be inserted.\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.AddOn_Par+"|"+DefPar.AddOn_Par.Insert_Func, "Identifier of the function into which the parameter should be inserted.\n(See 'EUROMOD Functions - Identifiers and the placeholders =cc= and =sys=' for information on identifiers.)" },
            { DefFun.AddOn_Par+"|"+DefPar.PAR_TYPE.PLACEHOLDER, "[Placeholder] stands for the name of the parameter to insert, defined in the policy column. The value of the parameter is specified in the respective system column (i.e. the may be system specific)." },
            { DefFun.DefInput+"|"+DefPar.DefInput.path, "Path of the input file." },
            { DefFun.DefInput+"|"+DefPar.DefInput.file, "Name of the input file." },
            { DefFun.DefInput+"|"+DefPar.DefInput.RowMergeVar, "ColMergeVar != n/a means 'lookup mode', i.e. one EUROMOD variable (per person) is set to a specific value looked up in the input file. The variable is defined by InputVar. Which value is looked up depends on the person's value of the variable defined by RowMergeVar as well as the person's value of the variable defined by ColMergeVar. The lookup value is the value of the cell whose row and column headers in the input file coincide with these variables.\n\nColMergeVar = n/a: means 'input mode', i.e. one or more EUROMOD variables (per person) are set to values defined in a specific row of the input file. The header row of the input file names the respective variables, while the other rows contain their values in the same order. One of these variables must be the variable defined by RowMergeVar. The row selected for a person is the one where the person's value of RowMergeVar coincides with the value of this variable in the input file. Note that, other than for the 'lookup mode', the RowMergeVar does not need to be located in the first column of the input file.\n\nNote that the variables inputted in 'input mode' as well as the variable defined by InputVar must exist, i.e. be defined in the variables file or by EUROMOD functions (e.g. DefVar)." },
            { DefFun.DefInput+"|"+DefPar.DefInput.ColMergeVar, "See description of parameter RowMergeVar." },
            { DefFun.DefInput+"|"+DefPar.DefInput.InputVar, "See description of parameter RowMergeVar." },
            { DefFun.DefInput+"|"+DefPar.DefInput.DefaultIfNoMatch, "Input variable(s) are set to this value if no match can be established.\nIf not defined an error message is issued if no match can be established." },
            { DefFun.DefInput+"|"+DefPar.DefInput.IgnoreNRows, "The first n rows of the input file are ignored (e.g. because they contain descriptions or headings)." },
            { DefFun.DefInput+"|"+DefPar.DefInput.IgnoreNCols, "The first n columns of the input file are ignored (e.g. because they contain descriptions or headings)." },
            { DefFun.DefInput+"|"+DefPar.DefInput.DoRanges, "If set to yes, matches are established by considering RowMergeVar and ColMergeVar in the input file as upper limits.\nExample: RowMergeVar dag in the input file set to 10, 30, 70, 150 \nInterpretation:\nall persons aged up to 10 (including) are assigned the value of the 10-column,\nall persons aged older than 10 up to 30 are assigned the value of the 30-column,\nall persons aged older than 30 up to 70 are assigned the value of the 70-column,\nall persons aged older than 70 up to 150 are assigned the value of the 150-column,\nno match is found for anyone older than 150." },
            { DefFun.DefInput+"|"+DefPar.DefInput.RepByEMPath, "Any occurrences of RepByEMPath in parameter Path are replaced by the path of the current EUROMOD installation.\nExample: RepByEMPath = &, Path = &Tools\\SomeFile.xls, EUROMOD is installed at C:\\EuromodFiles\\ \nResult: Path is interpreted as C:\\EuromodFiles\\Tools\\SomeFile.xls.\n\nNote that this parameter is only available under Windows as it uses platform specific functions.\n\nRemark: To assess the path of the current EUROMOD installation it is assumed that the files belonging to the EUROMOD bundle are installed in the standard configuration. Technically the programme assesses the path of the executable and assumes that the executable is located in the Executable folder, which itself is located is in the root of the EUROMOD installation. In other words the resulting folder is the folder, which is superordinate to the folder containing the executable." },
            { DefFun.Scale+"|"+DefPar.Scale.FactorVariables, "All monetary variables are multiplied by this factor. The operation concerns all monetary variables existing at the time of execution (i.e. used before). If the function is part of a loop, the scaling is done in each iteration." },
            { DefFun.Scale+"|"+DefPar.Scale.FactorParameter, "All monetary parameters are multiplied by this factor. Monetary parameters are identified by having a period (#m, #y, etc). Rates (#mr, #yr, etc.) are considered non-monetary. The operation concerns all parameters defined after the Scale function. Loops have no effect (i.e. the scaling is done once)." },
            { DefFun.AddOn_ExtensionSwitch+"|"+DefPar.AddOn_ExtensionSwitch.Extension_Name, "Name of the extension (long- and short name can be used) e.g. 'benefit take-up adjustments' or 'BTA'." },
            { DefFun.AddOn_ExtensionSwitch+"|"+DefPar.AddOn_ExtensionSwitch.Extension_Id, "Identifier of the extension (look up in XML or use Extension_Name instead)." },
            { DefFun.AddOn_ExtensionSwitch+"|"+DefPar.AddOn_ExtensionSwitch.Extension_Switch, "'on' for switching extension on, 'off' for switching off." },
            { DefFun.AddOn_ExtensionSwitch+"|"+DefPar.AddOn_ExtensionSwitch.Dataset, "If any 'Dataset' parameter is used, the setting is only applied if one of them matches the dataset of the concerned run. The wildcards * and ? can be used, where * stands for any character and ? stands for one arbitrary character (e.g. be_20*_a?)." },
            { DefFun.AddOn_ExtensionSwitch+"|"+DefPar.AddOn_ExtensionSwitch.System, "If any 'System' parameter is used, the setting is only applied if one of them matches the system of the concerned run. The wildcards * and ? can be used, where * stands for any character and ? stands for one arbitrary character (e.g. be_20??)." },
            { DefFun.AddHHMembers+"|"+DefPar.AddHHMembers.Add_Who, "Defines whether children or partners or other persons are added." },
            { DefFun.AddHHMembers+"|"+DefPar.AddHHMembers.ParentCond, "Condition a person must fulfill to be a parent (i.e. a child is added for the person). Only relevant if Add_Who=Child." },
            { DefFun.AddHHMembers+"|"+DefPar.AddHHMembers.PartnerCond, "Condition a person must fulfill to be a partner (i.e. a partner is added for the person). Only relevant if Add_Who=Partner." },
            { DefFun.AddHHMembers+"|"+DefPar.AddHHMembers.HHCond, "Condition the household must fulfill for adding a new person. Only relevant if Add_Who=Other." },
            { DefFun.AddHHMembers+"|"+DefPar.AddHHMembers.IsPartnerParent, "If yes, the partner of the new parent (person fulfilling ParentCond) gets the other partent of the added child. Only relevant if Add_Who=Child." },
            { DefFun.AddHHMembers+"|"+DefPar.PAR_TYPE.PLACEHOLDER, "Initial value for any variable of the new person (e.g. dag, dgn, dec, ...)." },
            { DefFun.Break+"|"+DefPar.Break.ProduceOutput, "If yes, all variables are dumped in an output file." },
            { DefFun.Break+"|"+DefPar.Break.OutputFileName, "Specifies the name of the output file. If not indicated or n/a the program searches for the first DefOutput after the Break and takes the name from there. The path is defined as usual for DefOutput (i.e. via the UI resp. the configuration file)." },
            { DefFun.Break+"|"+DefPar.Break.ProduceTUinfo, "If true, TU info is dumped to the output file for each TU defined before the Break (see DefOuput UnitInfo-parameters)." },
            { DefQuery.IsHeadOfTu, "Returns 1 if a person is the 'Head' of the assessment unit, i.e. fulfils the fixed head condition and the ExtHeadCond of the assessment unit specification, 0 otherwise.\nSee the (summary) description of function DefTU for further details." },
            { DefQuery.IsPartner, "Returns 1 if a person is the 'Partner' of the assessment unit, i.e. fulfils the PartnerCond of the assessment unit specification, 0 otherwise.\nSee the (summary) description of function DefTU for further details." },
            { DefQuery.IsDepChild, "Returns 1 if a person is a 'dependent child', i.e. fulfils the DepChildCond of the assessment unit specification, 0 otherwise.\nSee the (summary) description of function DefTU for further details." },
            { DefQuery.IsOwnChild, "Returns 1 if a person is an 'own child', i.e.  fulfils the OwnChildCond of the assessment unit specification, 0 otherwise.\nSee the (summary) description of function DefTU for further details." },
            { DefQuery.IsOwnDepChild, "Returns 1 if a person is an 'own dependent child', i.e. fulfils the OwnDepChildCond of the assessment unit specification, 0 otherwise.\nSee the (summary) description of function DefTU for further details." },
            { DefQuery.IsLooseDepChild, "Returns 1 if a person is a 'loose dependent child', i.e. fulfils the LooseDepChildCond of the assessment unit specification, 0 otherwise.\nSee the (summary) description of function DefTU for further details." },
            { DefQuery.IsDepParent, "Returns 1 if a person is a 'dependent parent', i.e. fulfils the DepParentCond of the assessment unit specification, 0 otherwise.\nSee the (summary) description of function DefTU for further details." },
            { DefQuery.IsDepRelative, "Returns 1 if a person is a 'dependent relative', i.e. fulfils the DepRelativeCond of the assessment unit specification, 0 otherwise.\nSee the (summary) description of function DefTU for further details." },
            { DefQuery.IsLoneParentOfDepChild, "Returns 1 if a person is a 'lone parent', i.e. fulfils the LoneParentCond of the assessment unit specification, 0 otherwise. \nSee the (summary) description of function DefTU for further details." },
            { DefQuery.IsMarried, "Returns 1 if a person is married, i.e. variable dms = 2, 0 otherwise." },
            { DefQuery.IsCohabiting, "Returns 1 if a person has a partner, i.e. variable idpartner > 0, and is not married, i.e. variable dms != 2, 0 otherwise." },
            { DefQuery.IsWithPartner, "Returns 1 if a person has a partner, i.e. variable idpartner > 0, irrespective of being married, i.e. the variable dms, 0 otherwise." },
            { DefQuery.IsInEducation, "Returns 1 if a person is in education, i.e. variable dec > 0 and variable les = 6, 0 otherwise." },
            { DefQuery.IsDisabled, "Returns 1 if a person is disabled, i.e. variable ddi > 0, if ddi does not exist ddilv is used, if both do not exist the query is ignored, 0 otherwise." },
            { DefQuery.IsCivilServant, "Returns 1 if a person is a civil servant, i.e. variable lcs = 1, 0 otherwise" },
            { DefQuery.IsBlueColl, "Returns 1 if a person is a blue-collar worker, i.e. variable loc = 6 (skilled agriculture) or 7 (craft worker) or 8 (plant operator) or 9 (elementary occupation) or 0 (armed force), 0 otherwise." },
            { DefQuery.IsParent, "Returns 1 if a person has at least one child, i.e. idMother[child] = idPerson[person] or idFather[child] = idPerson[person], 0 otherwise.\nNote that the query is independent of any assessment unit definition (e.g. as there is no child definition, 'children' have no age limit)." },
            { DefQuery.IsParentOfDepChild, "Returns 1 if\n- either at least one 'own dependant child' of the person belongs to the assessment unit\n- or at least one 'loose dependent child' belongs to the assessment unit and the person is 'Head' or 'Partner'\nwhere\n- for being an 'own dependent child' query IsDepChild must apply\n- for being a 'loose dependent child' query IsLooseDepChild must apply\n- for being 'Head' query IsHead must apply\n- for being 'Partner' query IsPartner must apply\n0 otherwise." },
            { DefQuery.IsLoneParent, "Is equivalent to IsParent & !IsWithPartner." },
            { DefQuery.nChildrenOfCouple, "Returns the number of a couple's children.\n\nFor a specific assessment unit 'couple's children' must fulfil each of the following three conditions:\n(1) idMother[child] = idPerson[Head] or idMother[child] = idPerson[Partner] or idFather[child] = idPerson[Head] or idFather[child] = idPerson[Partner] \n(2) dag[child] >= parameter #_AgeMin\n(3) dag[child] <= parameter #_AgeMax\nwhere\n- for being 'Head' query IsHead must apply\n- for being 'Partner' query IsPartner must apply\n\nNote that children of the whole household are counted (not just children belonging to the assessment unit) and that no assessment unit specific child definition is applied." },
            { DefQuery.nDepChildrenOfCouple, "Returns the number of a couple's dependent children.\n\nFor a specific assessment unit 'couple's dependent children' must fulfil each of the following five conditions:\n(1) query IsDepChild or query IsLooseDepChild applies\n(2) child is part of the assessment unit\n(3) idMother[child] = idPerson[Head] or idMother[child] = idPerson[Partner] or idFather[child] = idPerson[Head] or idFather[child] = idPerson[Partner] or idMother[child] = idFather[child] = 0\n(4) dag[child] >= parameter #_AgeMin\n(5) dag[child] <= parameter #_AgeMax\nwhere\n- for being 'Head' query IsHead must apply\n- for being 'Partner' query IsPartner must apply" },
            { DefQuery.nPersInUnit, "Returns the number of persons in the assessment unit who fulfil dag >= parameter #_AgeMin and dag<=#_AgeMax." },
            { DefQuery.nAdultsInTu, "Returns the number of adults in the assessment unit who fulfil dag >= parameter #_AgeMin and dag <= parameter #_AgeMax.\nFor being counted as adult the query IsDepChild must not apply." },
            { DefQuery.nDepChildrenInTu, "Returns the number of dependent children in the assessment unit who fulfil dag >= parameter #_AgeMin and dag <= parameter #_AgeMax.\nFor being counted as dependent child the query IsDepChild must apply." },
            { DefQuery.nLooseDepChildrenInTu, "Returns the number of loose dependent children in the assessment unit.\nFor being counted as loose dependent child the query IsLooseDepChild must apply." },
            { DefQuery.nDepParentsInTu, "Returns the number of dependent parents in the assessment unit.\nFor being counted as dependent parent the query IsDepParent must apply." },
            { DefQuery.nDepRelativesInTu, "Returns the number of dependent relatives in the assessment unit.\nFor being counted as dependent relative the query IsDepRelative must apply." },
            { DefQuery.nDepParentsAndRelativesInTu, "Is equivalent to nDepParentsInTu + nDepRelativesInTu." },
            { DefQuery.IsNtoMchild, "Returns 1 if a person belongs to the n  to m oldest dependent children of the assessment unit, 0 otherwise.\nFor being counted as 'dependent child' query IsDepChild must apply.\nn and m are defined by parameters #_N and #_M. \n\nIf children are equally aged, they are sorted by idPerson, i.e. children with lower idPerson are considered to be younger than their equally aged siblings.\n\nExample:\n#_N = 2,  #_M=4.\nAssesment unit comprises 6 children aged 12, 10, 8, 6, 4 and 2.\nCondition is fulfilled for the 2nd-oldest (10), the 3rd-oldest (8) and the 4th-oldest (6) child." },
            { DefQuery.HasMaxValInTu, "Returns 1 if a person has the highest value of a specific variable in the assessment unit, 0 otherwise.\nParameter #_val defines the specific value.\nParameter #_unique treats the case of several persons with the same highest value: If set to yes, the return value is 1 for the person first occurring in the dataset only, otherwise for all persons with this value.\nIf parameter #_adults_only is set to yes dependent children cannot be selected unless there is no adult in the assessment unit. For being regarded a 'dependent child' query IsDepChild must apply." },
            { DefQuery.HasMinValInTu, "Returns 1 if a person has the lowest value of a specific variable in the assessment unit, 0 otherwise.\nParameter #_val defines the specific value.\nParameter #_unique treats the case of several persons with the same lowest value: If set to yes, the return value is 1 for the person first occurring in the dataset only, otherwise for all persons with this value.\nIf parameter #_adults_only is set to yes dependent children cannot be selected unless there is no adult in the assessment unit. For being regarded a 'dependent child' query IsDepChild must apply." },
            { DefQuery.GetPartnerIncome, "Returns an 'income' of a person's partner (defined as person's[idpartner] = partner's[idperson]).\nParameter #i_income defines the relevant income.\nNote that the query is independent of any assessment unit definition (and being married)." },
            { DefQuery.GetMotherIncome, "Returns an 'income' of a person's mother (defined as person's[idmother] = mother's[idperson]).\nParameter #i_income defines the relevant income.\nNote that the query is independent of any assessment unit definition." },
            { DefQuery.GetFatherIncome, "Returns an 'income' of a person's father (defined as person's[idfather] = father's[idperson]).\nParameter #i_income defines the relevant income.\nNote that the query is independent of any assessment unit definition." },
            { DefQuery.GetCoupleIncome, "Returns an 'income' of a person and her/his partner (defined as person's[idpartner] = partner's[idperson]).\nParameter #i_income defines the relevant income.\nNote that the query is independent of any assessment unit definition (and being married)." },
            { DefQuery.GetParentsIncome, "Returns an 'income' of a person's mother and father (defined as person's[idmother/idfather] = mother's/father's[idperson]).\nParameter #i_income defines the relevant income.\nNote that the query is independent of any assessment unit definition." },
            { DefQuery.GetOwnChildrenIncome, "Returns an 'income' of a person's own children (defined as child's[idmother or idfather] = persons's[idperson]).\nParameter #i_income defines the relevant income.\nNote that the query is independent of any assessment unit definition." },
            { DefQuery.GetSystemYear, "The query tries to extract the system's year from the system's name, by searching for 4 subsequent digits, and returns the result if found, -1 otherwise." },
            { DefQuery.GetDataIncomeYear, "Returns the income year of the applied dataset." },
            { DefQuery.IsOutputCurrencyEuro, "Returns 1 if the output currency of the system is Euro, 0 if national currency." },
            { DefQuery.IsParamCurrencyEuro, "Returns 1 if the system is parametrised in Euro, 0 if in national currency." },
            { DefQuery.GetExchangeRate, "Returns system's exchange rate from euro to national currency." },
            { DefQuery.IsUsedDatabase, "Returns 1 if a specific database is the database used by the current run.\nParameter #_DataBasename defines the respective database. The wildcards * and ? can be used, where * stands for any character and ? stands for one arbitrary character (e.g. be_20*_v?)." }
        };
    }
}
