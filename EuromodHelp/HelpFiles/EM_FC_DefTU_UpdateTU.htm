<!DOCTYPE html>
<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<link rel="stylesheet" href="files/style.css" />
<title>The system functions DefTU and UpdateTU</title>
</head>

<body>

<div class=Section1>

<h1>The system functions DefTU and UpdateTU</h1>

<p>The possibility of tailoring assessment units for any particular purpose, is one of
the big strengths of EUROMOD, but also requires careful application and some
mental effort. The function DefTU allows for defining
assessment units. In principle the function can be applied in any policy. For
reasons of transparency, assessment units are however usually defined centrally
in the special policy TUDef_cc. This rule may be
disregarded if a particular assessment unit is just used temporarily in one
special policy.</p>

<p>Once an assessment unit is defined it can be used by any subsequent function and policy. It is however important to know, at which point of the model spine the values of variables (and derivatively incomelists) are assessed. An example may help to understand this issue and its implications. Imagine a family assessment unit, defining a child as a person with &quot;income&quot; below a certain amount. At the start of the model spine this income may not be known, as benefits and taxes are not yet calculated. Therefore, assessing the income at this point would need to leave out any simulated variables. As this is not a good solution, the value of variables is assessed once the assessment unit is first used <a href="#_ftn1" name="_ftnref1" title="">[1]</a>. Note, however, that from this point the value is not reassessed! That means, if the income refers to a variable that changes after the first usage of the assessment unit and the assessment unit is reused after this change, everybody defined as child in first instance will still be a child, even if the income condition is not valid anymore. The model applies this behaviour as, for consistency reasons, it does not want to allow a change in the status of a person (i.e. a child becoming an adult, following this example) within the same simulation (at the same point in time). This is aggravated if units change, i.e. if persons drop out of their original unit, as they are e.g. not a child anymore. As this behaviour still may be unwanted, the function UpdateTU provides the possibility to reassess any assessment unit conditions, as will be described below. Let’s however start with more basic issues.</p>

<h4>Types and members of assessment units</h4>

<p>Example 1
illustrates three very basic uses of the function DefTU
and introduces the parameters type and members.</p>

<table class="spine">
	<caption>Example 1:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>household_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>HH</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>individual_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>IND</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>family_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td>Partner &amp; OwnChild</td>
		<td></td>
	</tr>
</table>

<p>The three definitions of assessment units in example 1 mainly differ by
their composition, which is primarily described by the parameter type. There are three possible types:</p>
<ul>
	<li>HH denotes that all members of the household belong to the same assessment unit.</li>

	<li>IND denotes that each member of the household forms its own assessment unit.</li>

	<li>SUBGROUP denotes that the household may be split into several assessment units of
	different size. Which household member belongs to which unit primarily depends on the parameter members.</li>
</ul>

<p>Some example households may illustrate these types.</p>

<table class="info">
	<tr>
		<th>description</th>
		<th>idhh</th>
		<th>idperson</th>
		<th>idpartner</th>
		<th>idmother</th>
		<th>idfather</th>
		<th>dag</th>
		<th>household_sl</th>
		<th>individual_sl</th>
		<th>family_sl</th>
	</tr>
	<tr class="separate">
		<td rowspan="4">family</td>
		<td>1</td>
		<td>101</td>
		<td>102</td>
		<td>0</td>
		<td>0</td>
		<td>30</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>1</td>
		<td>102</td>
		<td>101</td>
		<td>0</td>
		<td>0</td>
		<td>28</td>
		<td>A</td>
		<td>B</td>
		<td>A</td>
	</tr>
	<tr>
		<td>1</td>
		<td>103</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>3</td>
		<td>A</td>
		<td>C</td>
		<td>A</td>
	</tr>
	<tr>
		<td>1</td>
		<td>104</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>1</td>
		<td>A</td>
		<td>D</td>
		<td>A</td>
	</tr>
	<tr class="separate">
		<td rowspan="2">family</td>
		<td>2</td>
		<td>201</td>
		<td>202</td>
		<td>0</td>
		<td>0</td>
		<td>56</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>2</td>
		<td>202</td>
		<td>201</td>
		<td>0</td>
		<td>0</td>
		<td>55</td>
		<td>A</td>
		<td>B</td>
		<td>A</td>
	</tr>
	<tr class="separate">
		<td rowspan="2">lone parent</td>
		<td>3</td>
		<td>301</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>35</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>3</td>
		<td>302</td>
		<td>0</td>
		<td>301</td>
		<td>0</td>
		<td>6</td>
		<td>A</td>
		<td>B</td>
		<td>A</td>
	</tr>
	<tr class="separate">
		<td>single</td>
		<td>4</td>
		<td>401</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>25</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr class="separate">
		<td rowspan="2">two singles<br>living together</td>
		<td>5</td>
		<td>501</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>22</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>5</td>
		<td>502</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>23</td>
		<td>A</td>
		<td>B</td>
		<td>B</td>
	</tr>
	<tr class="separate">
		<td rowspan="6">large family</td>
		<td>6</td>
		<td>601</td>
		<td>602</td>
		<td>606</td>
		<td>0</td>
		<td>48</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>6</td>
		<td>602</td>
		<td>601</td>
		<td>0</td>
		<td>0</td>
		<td>45</td>
		<td>A</td>
		<td>B</td>
		<td>A</td>
	</tr>
	<tr>
		<td>6</td>
		<td>603</td>
		<td>0</td>
		<td>602</td>
		<td>601</td>
		<td>20</td>
		<td>A</td>
		<td>C</td>
		<td>A</td>
	</tr>
	<tr>
		<td>6</td>
		<td>604</td>
		<td>0</td>
		<td>602</td>
		<td>601</td>
		<td>15</td>
		<td>A</td>
		<td>D</td>
		<td>A</td>
	</tr>
	<tr>
		<td>6</td>
		<td>605</td>
		<td>0</td>
		<td>602</td>
		<td>601</td>
		<td>10</td>
		<td>A</td>
		<td>E</td>
		<td>A</td>
	</tr>
	<tr>
		<td>6</td>
		<td>606</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>70</td>
		<td>A</td>
		<td>F</td>
		<td>B</td>
	</tr>
</table>

<p>For the assessment unit household_sl, with
parameter type set to HH,
all members of all household types belong to one unit, the unit A <a href="#_ftn2" name="_ftnref2" title="">[2]</a>. In contrast, for the assessment unit individual_sl,
with parameter type set to IND,
all members of all household types belong to a different unit, units A to F.
For the assessment unit family_sl, parameter type is set to SUBGROUP, i.e.
the household is potentially split up into several units. With respect to the
parameter members such a unit comprises Partners and OwnChildren. To
interpret this, one needs to know that these relations are conceived in relation
to the &quot;head&quot; of the assessment unit, i.e. the parameter members must be read as follows: an assessment unit, as
defined by family_sl, consists of the
&quot;head&quot;, her/his &quot;partner&quot; and their &quot;own children&quot;.
The paragraphs below will explain the double quoted terms in detail, for now
we settle for their intuitive meaning. Household 1 consists of a head, a
partner (note variable idpartner) and their two own
children (note variables idmother/idfather), therefore they all belong to one unit A.
Household 2 consists of a couple, i.e. head and partner, they also belong both
to unit A. Household 3 consists of a lone parent and her/his child, i.e. head
and own child, consequently they also belong both to unit A. Household 4 is a
single household, and so there can be only one unit (A). Household 5 is split into two one-person units A and B. The two singles
are neither partners nor children of each other, therefore they form separate
units. Finally, household 6 consists of unit A, comprising the head (person
601), her/his partner (person 602, note variable idpartner)
and their children (603, 604 and 605, note variables idmother/idfather). The grandparent (606) forms an own unit B, as
she/he is neither partner nor child of the head. Actually, with the information
at hand, person 601 was arbitrarily defined as (first) head, which leads us to
the next paragraph …</p>

<h4>Defining the head of an assessment unit</h4>

<p>The basic
definition of the head is more or less the only &quot;hard wired&quot; part of
the assessment unit definition and reads as follows: the head is the richest
member of the unit; if there are two or more equally rich persons, the oldest
is the head; if there are two or more equally rich and equally old persons, the
person with the lowest idperson is the head.
&quot;Richest&quot; is defined by the variable or incomelist indicated by
parameter HeadDefInc, which is set to ils_origy by default. Age is defined by the
variable dag. In fact, if the assessment unit type is SUBGROUP, finding the
head has to be repeated until all members of the household are assigned to a unit.
That means, firstly (simplifying) the richest person of the household is found
as first head and all persons fulfilling the relations defined by parameter members are assigned to her/his unit. Then, if any
household members are not yet assigned, the richest person among them is found
as the second head and all not yet assigned persons fulfilling the relations
defined by parameter members are assigned to her/his
unit. The last sentence is repeated until all household members are assigned to
a unit. Now it becomes clear, why it was arbitrary to declare person 601 as the
first head – it contained the implicit assumption, that he/she is richer than
anyone else in the household.</p>

<p>Though the
head condition cannot be erased, it still can be further defined by using the
parameter ExtHeadCond, which stands for extended
head condition. Example 2 demonstrates its use.</p>

<table class="spine">
	<caption>Example 2:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>household_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>HH</td>
		<td></td>
	</tr>
	<tr>
		<td>ExtHeadCond</td>
		<td>dgn=0</td>
		<td></td>
	</tr>
	<tr>
		<td>StopIfNoHeadFound</td>
		<td>no</td>
		<td></td>
	</tr>
</table>

<p>If an extended head condition is defined, only persons fulfilling the
condition can be head. That means, example 2 describes a matriarchal society,
as only women can be head. Among the women it is still the richest (oldest, …)
who is chosen to be head. This condition, however, entails a problem, as the
model does not allow for headless households. So what
happens to womanless households? Due to the parameter StopIfNoHeadFound
(whose default value is no) the model will drop the extended head condition 
where necessary, i.e. if there is no person (left within the not yet assigned
household members) fulfilling the condition, and the head is found by the usual
process. If however the StopIfNoHeadFound parameter was set to &quot;yes&quot;, 
the application would issue an error message once it comes across a household 
without any women and stop its execution.</p>

<p>Note, that
the extended head condition has a default value of !IsDepChild. That means that, 
if the parameter is not explicitly defined, children cannot be head and, if the 
parameter StopIfNoHeadFound is also set to &quot;yes&quot;, the model will issue an error 
message if there are adultless households. To understand the rational of these
defaults, consider the following household, a child condition of being younger
than 18 and parameter members set to Partner &amp; OwnDepChild.</p>

<table class="info">
	<tr>
		<th>idperson</th>
		<th>idpartner</th>
		<th>idmother</th>
		<th>idfather</th>
		<th>dag</th>
		<th>ils_origy</th>
		<th>ExtHeadCond=<br>!IsDepChild</th>
		<th>ExtHeadCond=1</th>
	</tr>
	<tr class="separate">
		<td>101</td>
		<td>102</td>
		<td>0</td>
		<td>0</td>
		<td>44</td>
		<td>0</td>
		<td>A</td>
		<td>B</td>
	</tr>
	<tr>
		<td>102</td>
		<td>101</td>
		<td>0</td>
		<td>0</td>
		<td>40</td>
		<td>0</td>
		<td>A</td>
		<td>B</td>
	</tr>
	<tr>
		<td>103</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>14</td>
		<td>0</td>
		<td>A</td>
		<td>B</td>
	</tr>
	<tr>
		<td>104</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>17</td>
		<td>100</td>
		<td>A</td>
		<td>A</td>
	</tr>
</table>

<p>The 17 years old person 104 is a dependent child, with respect to the
condition assumed above. However, he/she is also the &quot;richest&quot; person
in this very low income household. Without the extended head condition set to !IsDepChild, person 104 becomes the first head, without
any other persons in her/his unit (he/she has no partner or children). Person
101 becomes the second head with persons 102 (partner) and 103 (dependent
child) in her/his unit. In contrast, with the extended head condition set to !IsDepChild, person 104 is out ruled to be head. Instead
person 101, being the oldest, becomes the first head with all other household
members in her/his unit, including person 104, as he/she is his/her child. Hence, the
default extended head condition ensures that dependent children do not get
separated from their parents.</p>

<p>Disadvantageously,
the approach entails a problem. If the child condition generates adultless
households, the model will issue and error message and stop. This can be
avoided by setting the parameter StopIfNoHeadFound
to &quot;no&quot;, putting up with some child heads. If child
heads are unacceptable, one could still overwrite the extended head condition
(e.g. setting ExtHeadCond to 1),
and use the parameter NoChildIfHead, which is explained
in more detail in the next paragraph.</p>

<p>Before
turning to this, note that the default of parameter ExtHeadCond
is overwritten in example 2. If this is unwanted, the parameter must be changed
to Default &amp; dgn=0. This will be explained in
more detail in the next section.</p>

<h4>Defining dependent children</h4>

<p>The
previous paragraph described the conditions for determining the head and the
next paragraph will describe a couple of conditions defining other
&quot;statuses&quot; within the assessment unit. This paragraph picks up the
condition for being a dependent child. An own paragraph is devoted to this
issue, not only it is one of the most important parts of assessment unit
specifications, but also as it is frequently a prerequisite for other conditions
(as it is in fact the case for the already discussed extended head condition !IsDepChild). Being a dependent child is specified by
the parameter DepChildCond. Example 3 illustrates
the use of this parameter.</p>

<table class="spine">
	<caption>Example 3:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>household_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>HH</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td>dag&lt;=15 | (dag&lt;=19 &amp; IsInEducation)</td>
		<td></td>
	</tr>
</table>
	

<p>In the example all persons up to 15 years are dependent children, as well
as persons up to 19 years, if they are in education. Note, that in this example
the child definition has no influence on the composition of the assessment unit
– as it is a household assessment unit anyway all household members belong to
the same unit. A child definition may however still be necessary, if for
example certain benefits depend on the number of children. Sometimes it even
makes sense to use the parameter DepChildCond with
an individual assessment unit. Anyway, the next example illustrates the use of
the child condition for assigning household members to assessment units.</p>

<table class="spine">
	<caption>Example 4:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>family_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td>Partner &amp; OwnDepChild</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td>dag&lt;=15 | (dag&lt;=19 &amp; IsInEducation)</td>
		<td></td>
	</tr>
</table>


<p>An example household may provide an easier understanding of the
definitions in example 4.</p>

<table class="info">
	<tr>
		<th>idperson</th>
		<th>idpartner</th>
		<th>idmother</th>
		<th>idfather</th>
		<th>dag</th>
		<th>IsInEducation</th>
		<th>ils_origy</th>
		<th>IsDepChild</th>
		<th>assessment unit</th>
	</tr>
	<tr class="separate">
		<td>101</td>
		<td>102</td>
		<td>0</td>
		<td>0</td>
		<td>44</td>
		<td>no</td>
		<td>2500</td>
		<td>0</td>
		<td>A</td>
	</tr>
	<tr>
		<td>102</td>
		<td>101</td>
		<td>0</td>
		<td>0</td>
		<td>40</td>
		<td>no</td>
		<td>1200</td>
		<td>0</td>
		<td>A</td>
	</tr>
	<tr>
		<td>103</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>21</td>
		<td>no</td>
		<td>1000</td>
		<td>0</td>
		<td>B</td>
	</tr>
	<tr>
		<td>104</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>19</td>
		<td>no</td>
		<td>800</td>
		<td>0</td>
		<td>C</td>
	</tr>
	<tr>
		<td>105</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>17</td>
		<td>yes</td>
		<td>0</td>
		<td>1</td>
		<td>A</td>
	</tr>
	<tr>
		<td>106</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>10</td>
		<td>yes</td>
		<td>0</td>
		<td>1</td>
		<td>A</td>
	</tr>
</table>


<p>Person 101 is the first head of this household, as he/she is the richest. He
forms the assessment unit A together with person 102, his/her partner, and persons 105
and 106, their dependent children. Persons 103 and 104 are no dependent
children with respect to the definition of parameter DepChildCond.
Therefore, they do not belong to their father’s assessment unit, but form own
units B and C. You may be puzzled by the fact, that in example 1 (for
simplicity reasons) no child definition was used. In this example members was set to Partner &amp;
OwnChild instead of Partner &amp; Own<strong>Dep</strong>Child. The difference will be
explained below.</p>

<p>Before turning
to this two further parameters in context with the determination of dependent
children are presented in example 5.</p>

<table class="spine">
	<caption>Example 5:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>family_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td>Partner &amp; OwnDepChild</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td>dag&lt;=15 | (dag&lt;=19 &amp; IsInEducation)</td>
		<td></td>
	</tr>
	<tr>
		<td>ExtHeadCond</td>
		<td>1</td>
		<td></td>
	</tr>
	<tr>
		<td>NoChildIfHead</td>
		<td>yes</td>
		<td></td>
	</tr>
	<tr>
		<td>NoChildIfPartner</td>
		<td>yes</td>
		<td></td>
	</tr>
</table>

<p>Again some example households may illustrate what these parameter settings
effect. Note, that the default extended head condition, which usually prevents
dependent children from being head, is &quot;switched off&quot; – 1 means that everyone fulfils the condition, i.e.
everyone can potentially be a head.</p>

<table class="info">
	<tr>
		<th>idhh</th>
		<th>idperson</th>
		<th>idpartner</th>
		<th>idmother</th>
		<th>idfather</th>
		<th>dag</th>
		<th>IsInEducation</th>
		<th>ils_origy</th>
		<th>IsDepChild</th>
		<th>assessment unit</th>
	</tr>
	<tr class="separate">
		<td>1</td>
		<td>101</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>18</td>
		<td>yes</td>
		<td>0</td>
		<td><span style="text-decoration: line-through">1</span> 0</td>
		<td>A</td>
	</tr>
	<tr class="separate">
		<td>2</td>
		<td>201</td>
		<td>202</td>
		<td>0</td>
		<td>0</td>
		<td>21</td>
		<td>no</td>
		<td>1000</td>
		<td>0</td>
		<td>A</td>
	</tr>
	<tr>
		<td>2</td>
		<td>202</td>
		<td>201</td>
		<td>0</td>
		<td>0</td>
		<td>19</td>
		<td>yes</td>
		<td>0</td>
		<td><span style="text-decoration: line-through">1</span> 0</td>
		<td>A</td>
	</tr>
	<tr class="separate">
		<td>3</td>
		<td>301</td>
		<td>302</td>
		<td>0</td>
		<td>0</td>
		<td>40</td>
		<td>no</td>
		<td>0</td>
		<td>0</td>
		<td>B</td>
	</tr>
	<tr>
		<td>3</td>
		<td>302</td>
		<td>301</td>
		<td>0</td>
		<td>0</td>
		<td>39</td>
		<td>no</td>
		<td>0</td>
		<td>0</td>
		<td>B</td>
	</tr>
	<tr>
		<td>3</td>
		<td>303</td>
		<td>0</td>
		<td>302</td>
		<td>301</td>
		<td>18</td>
		<td>yes</td>
		<td>50</td>
		<td><span style="text-decoration: line-through">1</span> 0</td>
		<td>A</td>
	</tr>
</table>

<p>Household 1 consists of just one person, who needs to be the head, as
there is nobody else. However, person 101 is with respect to parameter DepChildCond a dependent child, as she/he is in education
and not older than 19. With the parameter NoChildIfHead
set to yes this condition is &quot;overruled&quot;,
i.e. being a head predominates being a dependent child. Note, that without
providing any further parameters or setting ExtHeadCond to 1, the model would issue an error message for
this household and stop, as the default of parameter ExtHeadCond (!IsDepChild)
does not allow for child heads. Another way of preventing the stop was
described above (setting parameter StopIfNoHeadFound
to no). This again highlights that modellers have
many options at their disposal, to set parameters as is useful for their
purposes, however it also demonstrates the necessity of putting some mental
effort into getting them right.</p>

<p>Household 2
consists of a young couple. Person 201 is head, as she/he is the richest.
Person 202 is her/his partner and therefore belongs to her/his unit. Person 202
is in education and not older than 19, i.e. a dependent child with respect to
parameter DepChildCond. However, with the parameter NoChildIfPartner set to &quot;yes&quot;
this condition is &quot;overruled&quot;, i.e. being a partner predominates
being a dependent child. Finally, household 3 consists of a couple without
income and their 18-year-old child, who has a tiny income. As there are no
preconditions for being head, this tiny income makes the 18-year-old first
head, though she/he is a dependent child with respect to parameter DepChildCond. Her/his parents do not belong to her/his
unit, as they are neither her/his partner nor her/his children, therefore they
form an own unit. If this split up of a family is &quot;good&quot; or not
depends on the application. The subject will be further discussed in the next section.</p>

<h4>Defining &quot;statuses&quot; within the assessment unit</h4>

<p>So far we
have used the parameter members, without really
explaining how it works. One can intuitively get the meaning of Partners or OwnChildren
belonging to the assessment unit, however a clear definition was missing up
until now. In fact, there is a parameter, which explicitly defines who is a
partner. Example 6 illustrates its use.</p>

<table class="spine">
	<caption>Example 6:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>couple1_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td>Partner</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>couple2_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td>Partner</td>
		<td></td>
	</tr>
	<tr>
		<td>PartnerCond</td>
		<td>head:idperson=idpartner</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>couple3_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td>Partner</td>
		<td></td>
	</tr>
	<tr>
		<td>PartnerCond</td>
		<td>Default &amp; IsMarried</td>
		<td></td>
	</tr>
</table>

<p>The first assessment unit in example 6, couple1_sl, does not explicitly define who is a partner.
We have however seen, that couples still are assigned to the same unit. This
happens, because the parameter PartnerCond has a
default value, which is applied by the model if the parameter is omitted. The
first and the second assessment unit, couple1_sl and
couple2_sl, are in fact identically, as the
parameter PartnerCond is set to its default value,
which is head:idperson=idpartner. To understand this
condition one needs to know that conditions used in assessment unit definitions
allow for two special features (in addition to those provided in general by
conditions, see section <a href="EM_FC_Elig.htm">EUROMOD Functions - The policy
function Elig</a>). One of them is the possibility to use the prefixes head: and partner:. They
denote, that the subsequent variable refers to the head and the
partner of the unit, respectively. Please note, that the prefixes can only be used with
variables, but not with incomelists or queries. Knowing this we can interpret head:idperson=idpartner, as a condition that states that the partner of the subgroup is the head's partner. Finally, the
third assessment unit in example 6, couple3_sl, uses
the second &quot;extra feature&quot; provided by assessment unit conditions, Default, which simply denotes the default setting of the
respective condition. That means, that the parameter PartnerCond
of couple3_sl translates to head:idperson=idpartner&amp;IsMarried.
In other words, this feature provides the possibility to further define the
default condition. In the example, partners are not only identified by their
id, but in addition they must be married.</p>

<p>Now we are in the position to list
the possible settings of the parameter members and
to interpret their meaning. The parameter allows for the following
&quot;types&quot; of unit members, to be combined by &amp;:</p>
<ul>
	<li>Partner defined by the parameter PartnerCond</li>
	<li>OwnDepChild defined by the parameter OwnDepCond</li>
	<li>LooseDepChild defined by the parameter LooseDepChildCond</li>
	<li>OwnChild defined by the parameter OwnChildCond</li>
	<li>DepParent defined by the parameter DepParentCond</li>
	<li>DepRelative defined by the parameter DepRelativeCond</li>
</ul>

<p>All of the ...Cond parameters have default values, which are intended
to ease model developer’s life, by being set to plausible values. However, what
may be plausible in general can make no sense at all for a special purpose.
Therefore developers need to be aware of these default settings and check if
they match their particular requirements.</p>

<p>To
understand the shortly following discussion of each ...Cond
parameter’s default value, and even more for changing or extending them, it is
necessary to know how the model processes the single conditions. For example,
if a condition uses the prefix :head, the head must
be identified beforehand. Similarly, if a condition uses IsDepChild,
then the parameter DepChildCond must be evaluated before.
The model interprets the conditions in the following order <a href="#_ftn3" name="_ftnref3" title="">[3]</a>:</p>

<ol>
	<li>DepChildCond</li>
	<li>LooseDepChildCond</li>
	<li>assessing head using amongst others ExtHeadCond</li>
	<li>PartnerCond</li>
	<li>OwnChildCond</li>
	<li>OwnDepChildCond</li>
	<li>DepParentCond</li>
	<li>DepRelativeCond</li>
	<li>LoneParentCond</li>
</ol>


<p>The order
tries to reflect the most common dependencies by interpreting relatively
&quot;independent&quot; conditions first, to allow for their usage in
subsequent conditions. Note, that not all of the conditions define a
&quot;type&quot; of the parameter members, namely DepChildCond, ExtHeadCond and LoneParentCond don’t. ExtHeadCond
specifies the head and therewith also defines a &quot;member type&quot; (as
explained above, the head is always member and therefore not explicitly listed
by the parameter members). DepChildCond
serves two purposes. Firstly, knowing who is a dependent child is frequently a
prerequisite for the other &quot;type&quot; conditions. Secondly, the child
status is often requested in &quot;normal&quot; conditions of policy functions,
e.g. if it entitles to certain benefits. The latter is also the rational for
the parameter LoneParentCond. This raises the
question, how a status defined by one of the ...Cond
parameters can be retrieved, to be used e.g. with the function elig. The answer is, that for each condition a respective
query exists, e.g. the query connected to the parameter PartnerCond
is called IsPartner, the query connected to the parameter
DepChildCond is called IsDepChild,
etc. See section <a href="EM_FC_Queries.htm">EUROMOD Functions - Queries</a>
for a full list.</p>

<p>Now, let’s turn to the default
values of the single conditions. The following listing explains them in words,
for a formal (and therewith possibly more precise) definition see section <a
href="EM_FC_Sum_DefTU.htm">EUROMOD Functions - Summary of parameters for
functions DefTU and UpdateTU</a>.</p>

<ul>
	<li><strong>DepChildCond:</strong> If the parameter is not explicitly defined, nobody is a dependent child.
	There is however a default setting that can be assessed with Default, whose main purpose is to avoid the split up of
	families and is explained in more detail below.</li>

	<li><strong>LooseDepChildCond:</strong> The default definition of a &quot;loose&quot; dependent child
	describes a person, who is a dependent child with respect to DepChildCond, but has neither mother nor father with
	respect to the variables idmother or idfather <a href="#_ftn4" name="_ftnref4" title="">[4]</a>. Loose dependent children are
	frequently a problem, if they form their own assessment unit, as they are not
	identified as the child of some adult. Imagine a three years old receiving its
	own child benefit, as it is the head of its own unit. Therefore the parameter members allows for the explicit assignment of loose
	dependent children – if the type LooseDepChild is
	used, they are assigned to the first head’s unit. In fact, the three years old
	example should be theory, as this is bad dataset definition. However, with a
	generous DepChildCond (e.g. high age limits) loose
	dependent children are still possible.</li>

	<li><strong>ExtHeadCond:</strong> This parameter and its default setting is described above.</li>

	<li><strong>PartnerCond:</strong> This parameter and its default setting are described above.</li>

	<li><strong>OwnChildCond:</strong> The default definition of an own child is being the child of the head
	or her/his partner (as defined by PartnerCond) with
	respect to the variables idmother or idfather <a href="#_ftn4" title="">[4]</a>. Note, that a such defined child
	does not need to be a dependent child (as defined by DepChildCond),
	which may lead to odd constellations. For illustration, imagine an extended
	family, where a 70-year-old grandfather with a high pension lives with his 40
	years old son and his his partner and children. Setting members to OwnChild may result in splitting the household in a unit with
	the grandfather and his son and another unit with the partner and the
	children. More about this below.</li>

	<li><strong>OwnDepChildCond:</strong> The default definition of an own child is being an own child (as
	defined by OwnChildCond) and being a dependent child
	(as defined by DepChildCond). In general parameter OwnDepChild is preferable over OwnChild
	to be used with parameter members.</li>

	<li><strong>DepParentCond:</strong> The default definition of a dependent parent is being the parent of
	the head or her/his partner (as defined by PartnerCond)
	with respect to the variables idmother or idfather <a href="#_ftn5" name="_ftnref5" title="">[5]</a>. Note, that this condition in fact does
	not define any &quot;dependency&quot;. That’s because such a dependency can
	hardly be generalised, but depends on circumstances. That means that, if the
	parameter members includes the type DepParent, it is nearly always necessary to further define
	the parameter DepParentCond as Default&amp;….</li>

	<li><strong>DepRelativeCond:</strong> The default definition of a dependent relative is 0,
	i.e. not being a dependent relative. That means that, if the parameter members includes the type DepRelative,
	the parameter DepRelativeCond must define such a
	dependent relative.</li>

	<li><strong>LoneParentCond:</strong> The default definition of a lone parent is being the parent of at
	least one dependent child (as defined by DepChildCond)
	with respect to the variables idmother or idfather <a href="#_ftn4" title="">[4]</a> and not having a partner with respect to
	variable idpartner.</li>
</ul>

<h4>Avoiding to split up families</h4>

<p>This section presents some parameters, which may help to avoid the split
up of households into odd units. Let’s start this by explaining the rational
for the Default of the parameter DepChildCond. As briefly mentioned above, if the parameter
is not explicitly defined, nobody is a dependent child. There is however a
default setting that can be assessed with Default,
which translates to !isparent &amp; idpartner=0.
The first part of this setting !isparent prevents
that children get separated from their child-parents and the second part idpartner=0 prevents that partners get separated from
their child-partners. This is illustrated by example 7.</p>

<table class="spine">
	<caption>Example 7:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>family1_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td>Partner &amp; OwnDepChild</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>family2_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td>Partner &amp; OwnDepChild</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td>dag&lt;20 &amp; ils_origy=0</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>family3_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td>Partner &amp; OwnDepChild</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td>Default &amp; dag&lt;20 &amp; ils_origy=0</td>
		<td></td>
	</tr>
</table>	

<p>Again some example households may illustrate what these parameter
settings effect.</p>

<table class="info">
	<tr>
		<th rowspan="2">idhh</th>
		<th rowspan="2">idperson</th>
		<th rowspan="2">idpartner</th>
		<th rowspan="2">idmother</th>
		<th rowspan="2">idfather</th>
		<th rowspan="2">dag</th>
		<th rowspan="2">ils_origy</th>
		<th colspan="3">IsDepChild</th>
		<th colspan="3">assessment unit</th>
	</tr>
	<tr>
		<th>fam1</th>
		<th>fam2</th>
		<th>fam3</th>
		<th>fam1</th>
		<th>fam2</th>
		<th>fam3</th>
	</tr>
	<tr>
		<td>1</td>
		<td>101</td>
		<td>102</td>
		<td>0</td>
		<td>0</td>
		<td>37</td>
		<td>2500</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>1</td>
		<td>102</td>
		<td>101</td>
		<td>0</td>
		<td>0</td>
		<td>35</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>1</td>
		<td>103</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>6</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>B</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>1</td>
		<td>104</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>C</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr class="separate">
		<td>2</td>
		<td>201</td>
		<td>202</td>
		<td>0</td>
		<td>0</td>
		<td>45</td>
		<td>2000</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>2</td>
		<td>202</td>
		<td>201</td>
		<td>0</td>
		<td>0</td>
		<td>43</td>
		<td>1500</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>2</td>
		<td>203</td>
		<td>204</td>
		<td>202</td>
		<td>201</td>
		<td>19</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>B</td>
		<td>A</td>
		<td>B</td>
	</tr>
	<tr>
		<td>2</td>
		<td>204</td>
		<td>203</td>
		<td>0</td>
		<td>0</td>
		<td>18</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>B</td>
		<td>B</td>
		<td>B</td>
	</tr>
	<tr class="separate">
		<td>3</td>
		<td>301</td>
		<td>302</td>
		<td>0</td>
		<td>0</td>
		<td>45</td>
		<td>2000</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>3</td>
		<td>302</td>
		<td>301</td>
		<td>0</td>
		<td>0</td>
		<td>43</td>
		<td>1500</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>A</td>
		<td>A</td>
		<td>A</td>
	</tr>
	<tr>
		<td>3</td>
		<td>303</td>
		<td>0</td>
		<td>302</td>
		<td>301</td>
		<td>19</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>B</td>
		<td>A</td>
		<td>B</td>
	</tr>
	<tr>
		<td>3</td>
		<td>304</td>
		<td>0</td>
		<td>303</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>
		<td>C</td>
		<td>B</td>
		<td>B</td>
	</tr>
</table>

<p>To come straight to the point: the first assessment unit definition in
example 7, family1_sl, is nonsense, as it does not
provide a definition of dependent children. The second definition, family2_sl, at first view seems ok, but it involves some
problems. Finally, the third definition, family3_sl,
overcomes these problems, whether however the suggested solution is the desired
depends on the concrete requirements. Now, let’s investigate these statements.
Household 1: mother father and two small children. family1_sl does not even come up with this common family
structure. The children form their own unit as, due to the missing parameter DepChildCond, nobody is a dependent child. family2_sl and family3_sl seem
ok, persons 103 and 104 are dependent children and therefore assigned to unit
of their parents. Household 2: a young couple, having no
income, lives with the parents of one partner. In this case all three family
definitions show a split that is not obviously odd. With the definitions of family1_sl and family3_sl the
young couple forms an own unit. In both cases this is caused by the fact that
the 19 years old is not a dependent child and therefore gets split from her/his
parents. With the definition of family1_sl this is
caused by the missing dependent child condition, in contrast with the
definition of family3_sl the 19 years old is a
dependent child with respect to the age and income conditions, however she/he
does not fulfil the condition idpartner=0. family2_sl separates the child in law from the rest, as
the 19 years old in this case is a dependent child and therefore belongs to the
unit of her/his parents. As a result the child in law is left over without any
relation entitling her/him to belong to the unit of the parents of her/his
partner. Whether any of these splits is ok, depends on requirements. Finally,
household 3 comprises a young mother, having no income, who lives with her
child and her parents. As with household 1, family1_sl
shows an odd split due to the missing dependent child condition. This time also
family2_sl exhibits an odd split, as it separates the
small child from the rest of the family, for the same reasons why the child in
law was split from the rest in household 2. The grandchild has no relation
entitling it to belong to the unit of her grandparents. Note, that not even
including loose dependent children would solve the problem, because the baby is
no loose child, as it has a mother. Whether the split with family3_sl
is desired depends on requirements, at least it is plausible. The young mother
stays together with her child, as the condition !isparent
out rules her for being a dependent child herself, but the two get separated
from the grandparents.</p>

<p>As
foretelled the splits of family3_sl are &quot;not
odd&quot;, but intuitively one would think that the 19 year old with a partner
and the young mother, both having no income, are dependent children and
therefore should belong to the units of their parents. Example 8 illustrates
how to accomplish this by using the parameters AssignDepChOfDependents
and AssignPartnerOfDependents, which do what their
names imply.</p>

<table class="spine">
	<caption>Example 8:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td>family4_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td>Partner &amp; OwnDepChild</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td>dag&lt;20 &amp; ils_origy=0</td>
		<td></td>
	</tr>
	<tr>
		<td>AssignDepChOfDependents</td>
		<td>yes</td>
		<td></td>
	</tr>
	<tr>
		<td>AssignPartnerOfDependents</td>
		<td>yes</td>
		<td></td>
	</tr>
</table>

<p>The table below shows how this setting effects the three households
introduced above.</p>

<table class="info">
	<tr>
		<th>idhh</th>
		<th>idperson</th>
		<th>idpartner</th>
		<th>idmother</th>
		<th>idfather</th>
		<th>dag</th>
		<th>ils_origy</th>
		<th>IsDepChild</th>
		<th>assessment unit</th>
	</tr>
	<tr class="separate">
		<td>1</td>
		<td>101</td>
		<td>102</td>
		<td>0</td>
		<td>0</td>
		<td>37</td>
		<td>2500</td>
		<td>0</td>
		<td>A</td>
	</tr>
	<tr>
		<td>1</td>
		<td>102</td>
		<td>101</td>
		<td>0</td>
		<td>0</td>
		<td>35</td>
		<td>0</td>
		<td>0</td>
		<td>A</td>
	</tr>
	<tr>
		<td>1</td>
		<td>103</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>6</td>
		<td>0</td>
		<td>1</td>
		<td>A</td>
	</tr>
	<tr>
		<td>1</td>
		<td>104</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>1</td>
		<td>0</td>
		<td>1</td>
		<td>A</td>
	</tr>
	<tr class="separate">
		<td>2</td>
		<td>201</td>
		<td>202</td>
		<td>0</td>
		<td>0</td>
		<td>45</td>
		<td>2000</td>
		<td>0</td>
		<td>A</td>
	</tr>
	<tr>
		<td>2</td>
		<td>202</td>
		<td>201</td>
		<td>0</td>
		<td>0</td>
		<td>43</td>
		<td>1500</td>
		<td>0</td>
		<td>A</td>
	</tr>
	<tr>
		<td>2</td>
		<td>203</td>
		<td>204</td>
		<td>202</td>
		<td>201</td>
		<td>19</td>
		<td>0</td>
		<td>1</td>
		<td>A</td>
	</tr>
	<tr>
		<td>2</td>
		<td>204</td>
		<td>203</td>
		<td>0</td>
		<td>0</td>
		<td>18</td>
		<td>0</td>
		<td>1</td>
		<td>A</td>
	</tr>
	<tr class="separate">
		<td>3</td>
		<td>301</td>
		<td>302</td>
		<td>0</td>
		<td>0</td>
		<td>45</td>
		<td>2000</td>
		<td>0</td>
		<td>A</td>
	</tr>
	<tr>
		<td>3</td>
		<td>302</td>
		<td>301</td>
		<td>0</td>
		<td>0</td>
		<td>43</td>
		<td>1500</td>
		<td>0</td>
		<td>A</td>
	</tr>
	<tr>
		<td>3</td>
		<td>303</td>
		<td>0</td>
		<td>302</td>
		<td>301</td>
		<td>19</td>
		<td>0</td>
		<td>1</td>
		<td>A</td>
	</tr>
	<tr>
		<td>3</td>
		<td>304</td>
		<td>0</td>
		<td>303</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>A</td>
	</tr>
</table>	
	
<p>With the definitions of family4_sl the
incomeless child of household 2 and the young mother of household 3 now belong
to the units of their parents. But also the child in law of household 2 belongs
to the unit of her/his parents in law, as well as the small child of household
3 belongs to the unit of its grandparents, as they now have relationships (to
their partner respectively mother) entitling them to it.</p>

<h4>Using conditions which refer to income</h4>

<p>Income related conditions are frequently used elements in defining assessment units.
For example, child definitions often contain upper limits on income. However,
as elaborated in section <a href="EM_FC_ParameterValues.htm">EUROMOD Functions
- Parameter values and the assessment unit</a>, once a unit bigger than the
individual is concerned the level of interpreting variables or incomelists is
not necessarily intuitively clear at the outset. Therefore, the following
examples intend to exemplify how to get income related conditions right. To
understand the examples, please note, that the rules outlined in section <a
href="EM_FC_ParameterValues.htm">EUROMOD Functions - Parameter values and the
assessment unit</a> are also valid for the function DefTU.</p>

<p>Example 9 illustrates a child condition, which refers to the child’s income.</p>

<table class="spine">
	<caption>Example 9:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td>Grp/No</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td></td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td></td>
		<td>example1_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td></td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td></td>
		<td>Partner &amp; OwnDepChild</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td></td>
		<td>dag&lt;20 &amp; ils_origY#1&lt;200#m</td>
		<td></td>
	</tr>
	<tr>
		<td>#_level</td>
		<td>1</td>
		<td>individual_sl</td>
		<td></td>
	</tr>
</table>


<p>In the example dependent children are persons younger than 20, with own
income, as defined by incomelist ils_origY, below
200 Euro monthly. Note, that without specifying that ils_origY
should be assessed on individual level it would be assessed on assessment unit
level.</p>

<p>Example 10
illustrates a child condition, which refers to the income of the child’s
parents.</p>

<table class="spine">
	<caption>Example 10:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td>Grp/No</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td></td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td></td>
		<td>example2_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td></td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td></td>
		<td>Partner &amp; OwnDepChild</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td></td>
		<td>dag&lt;20 &amp; GetParentsIncome#1&lt;=1000#m</td>
		<td></td>
	</tr>
	<tr>
		<td>#_income</td>
		<td>1</td>
		<td>ils_origy</td>
		<td></td>
	</tr>
</table>


<p>In the example dependent children are persons younger than 20, whose
parents’ (as defined by variables idmother and idfather <a href="#_ftn6" name="_ftnref6" title="">[6]</a>)
income, as defined by incomelist ils_origY, does not
exceed 1,000 Euro monthly. (For the definition of the query GetParentsIncome also see section <a href="EM_FC_Queries.htm">EUROMOD
Functions - Queries</a>.)</p>

<p>Example 11
shows two dependent parent conditions, which refer to the joint income of a
potentially dependent parent and her/his partner.</p>

<table class="spine">
	<caption>Example 11:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td>Grp/No</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td></td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td></td>
		<td>example3_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td></td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td></td>
		<td>Partner &amp; OwnDepChild &amp; DepParent</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td></td>
		<td>dag&lt;20</td>
		<td></td>
	</tr>
	<tr>
		<td>DepParentCond</td>
		<td></td>
		<td>dag&gt;60 &amp; GetParentsIncome#1&lt;=1000#m</td>
		<td></td>
	</tr>
	<tr>
		<td>#_income</td>
		<td>1</td>
		<td>ils_origy</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td></td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td></td>
		<td>example4_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td></td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td></td>
		<td>Partner &amp; OwnDepChild &amp; DepParent</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td></td>
		<td>dag&lt;20</td>
		<td></td>
	</tr>
	<tr>
		<td>DepParentCond</td>
		<td></td>
		<td>dag&gt;60 &amp; ils_origy#1&lt;=1000#m</td>
		<td></td>
	</tr>
	<tr>
		<td>#_level</td>
		<td>1</td>
		<td>couple_sl</td>
		<td></td>
	</tr>
</table>

<p>The two assessment unit definitions in example 11 do the
same. Both define dependent parents as persons aged
older than 60. The joint income, as defined by incomelist ils_origY, of the person and her/his partner may not exceed
1,000 Euro monthly. The only difference is, that the query GetCoupleIncome used in the first version does not allow for an own
definition of &quot;partner&quot;, but refers to the partner
defined by the variable idpartner (also see section <a href="EM_FC_Queries.htm">EUROMOD Functions - Queries</a>), while in the second version the assessment unit couple_sl may use the parameter PartnerCond to specify who is a partner.</p>

<p>Example 12
illustrates a dependent parent condition which refers to the potentially
dependent parent’s own income as well as her/his partner’s income.</p>

<table class="spine">
	<caption>Example 12:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td>Grp/No</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td></td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td></td>
		<td>example4_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td></td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td></td>
		<td>Partner &amp; OwnDepChild &amp; DepParent</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td></td>
		<td>dag&lt;20</td>
		<td></td>
	</tr>
	<tr>
		<td>DepParentCond</td>
		<td></td>
		<td>dag&gt;60 &amp; ils_origy#1&lt;=1000#m &amp; GetPartnerIncome#2&lt;=500#m</td>
		<td></td>
	</tr>
	<tr>
		<td>#_level</td>
		<td>1</td>
		<td>individual_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>#_income</td>
		<td>2</td>
		<td>ils_origy</td>
		<td></td>
	</tr>
</table>


<p>In the example dependent parents are
persons aged older than 60, whose own income, as defined by incomelist ils_origY,
does not exceed 1,000 Euro monthly. Moreover, the income of their partner (with
respect to variable idpartner) may not exceed 500
Euro monthly. (For the definition of the query GetPartnerIncome see section <a href="EM_FC_Queries.htm">EUROMOD Functions - Queries</a>).</p>

<h4>Updating assessment units</h4>

<p>As outlined above, household members are assigned to respective units
once an assessment unit is first used. This assignment is not changed with
subsequent uses, even if circumstances change, i.e. some conditions are not
fulfilled anymore or get fulfilled at a later point in the model spine. However,
the reassessment of the units can be enforced by using the function UpdateTU. </p>

<p>Example 13 intends to illustrate these procedures.</p>

<table class="spine">
	<caption>Example 13:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td>Grp/No</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>DefIL</td>
		<td></td>
		<td class="on">on</td>
		<td>incomelist definitions</td>
	</tr>
	<tr>
		<td>name</td>
		<td></td>
		<td>il_earns</td>
		<td></td>
	</tr>
	<tr>
		<td>yem</td>
		<td></td>
		<td>+</td>
		<td></td>
	</tr>
	<tr>
		<td>yse</td>
		<td></td>
		<td>+</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>DefIL</td>
		<td></td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td></td>
		<td>il_MeansTest</td>
		<td></td>
	</tr>
	<tr>
		<td>il_earns</td>
		<td></td>
		<td>+</td>
		<td></td>
	</tr>
	<tr>
		<td>bed_s</td>
		<td></td>
		<td>+</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td></td>
		<td class="on">on</td>
		<td>assessment unit definitions</td>
	</tr>
	<tr>
		<td>name</td>
		<td></td>
		<td>individual_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td></td>
		<td>IND</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>DefTU</td>
		<td></td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>name</td>
		<td></td>
		<td>family_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>type</td>
		<td></td>
		<td>SUBGROUP</td>
		<td></td>
	</tr>
	<tr>
		<td>members</td>
		<td></td>
		<td>Partner & OwnDepChild</td>
		<td></td>
	</tr>
	<tr>
		<td>DepChildCond</td>
		<td></td>
		<td>dag&lt;25 &amp; il_MeansTest#1&lt;=500#m</td>
		<td></td>
	</tr>
	<tr>
		<td>#_level</td>
		<td>1</td>
		<td>individual_sl</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>ArithOp</td>
		<td></td>
		<td class="on">on</td>
		<td>child benefit</td>
	</tr>
	<tr>
		<td>formula</td>
		<td></td>
		<td>0</td>
		<td>initialise variable bed_s</td>
	</tr>
	<tr>
		<td>output_var</td>
		<td></td>
		<td>bed_s</td>
		<td>for the means test</td>
	</tr>
	<tr>
		<td>TAX_UNIT</td>
		<td></td>
		<td>individual_sl</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>ArithOp</td>
		<td></td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>formula</td>
		<td></td>
		<td>50#m * nDepChildrenInTu</td>
		<td></td>
	</tr>
	<tr>
		<td>output_var</td>
		<td></td>
		<td>bch_s</td>
		<td></td>
	</tr>
	<tr>
		<td>TAX_UNIT</td>
		<td></td>
		<td>family_sl</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>Elig</td>
		<td></td>
		<td class="on">on</td>
		<td>education benefit</td>
	</tr>
	<tr>
		<td>elig_cond</td>
		<td></td>
		<td>IsInEducation &amp; dag&gt;17 &amp; il_earns#1&lt;1500#m</td>
		<td></td>
	</tr>
	<tr>
		<td>#_level</td>
		<td>1</td>
		<td>family_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>TAX_UNIT</td>
		<td></td>
		<td>individual_sl</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>ArithOp</td>
		<td></td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>who_must_be_elig</td>
		<td></td>
		<td>one</td>
		<td></td>
	</tr>
	<tr>
		<td>formula</td>
		<td></td>
		<td>600#m</td>
		<td></td>
	</tr>
	<tr>
		<td>output_var</td>
		<td></td>
		<td>bed_s</td>
		<td></td>
	</tr>
	<tr>
		<td>TAX_UNIT</td>
		<td></td>
		<td>individual_sl</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>UpdateTU</td>
		<td></td>
		<td class="toggle">toggle</td>
		<td>assessment unit update</td>
	</tr>
	<tr>
		<td>name</td>
		<td></td>
		<td>family_sl</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>BenCalc</td>
		<td></td>
		<td class="on">on</td>
		<td>social assistance</td>
	</tr>
	<tr>
		<td>comp_cond</td>
		<td>1</td>
		<td>IsHead</td>
		<td></td>
	</tr>
	<tr>
		<td>comp_perElig</td>
		<td>1</td>
		<td>1000#m</td>
		<td></td>
	</tr>
	<tr>
		<td>comp_cond</td>
		<td>2</td>
		<td>IsPartner</td>
		<td></td>
	</tr>
	<tr>
		<td>comp_perElig</td>
		<td>2</td>
		<td>500#m</td>
		<td></td>
	</tr>
	<tr>
		<td>comp_cond</td>
		<td>3</td>
		<td>IsDepChild</td>
		<td></td>
	</tr>
	<tr>
		<td>comp_perElig</td>
		<td>3</td>
		<td>100#m</td>
		<td></td>
	</tr>
	<tr>
		<td>withdraw_base</td>
		<td></td>
		<td>il_earns</td>
		<td></td>
	</tr>
	<tr>
		<td>withdraw_rate</td>
		<td></td>
		<td>1</td>
		<td></td>
	</tr>
	<tr>
		<td>output_var</td>
		<td></td>
		<td>bsa_s</td>
		<td></td>
	</tr>
	<tr>
		<td>TAX_UNIT</td>
		<td></td>
		<td>family_sl</td>
		<td></td>
	</tr>
</table>

<p>Please note, that packing all these definitions and policies into one policy
sheet would be very bad programming style, and here is just done for the sake
of simplification. Let’s very briefly verbalise the essential ongoings in the
example, to then research the implications by looking at a sample household.
The relevant assessment unit is family_sl,
consisting of head, partner and own dependent children, where dependent
children are defined as being younger than 25 and having no own income above
500 Euro monthly. The relevant income is composed of earnings and an education
benefit, received by students older than 17, whose families dispose over
earnings of less than 1,500 Euro monthly. Two benefits are calculated using the
assessment unit family_sl: firstly, a child benefit
paying monthly 50 Euro per child, and secondly, a social assistance benefit
paying 1,000 Euro monthly for the head, 500 Euro for the partner and 100 Euro
for each dependent child in the assessment unit. Earnings are totally withdrawn
from this benefit. The following table shows the outcomes of these benefits for
an exemplary household, once with not updating the units defined by family_sl for its second application and once with
updating them. Note, that the switch of the function UpdateTU
is set to toggle. For the example this is to be
understood as it could be either switched on or off, as circumstances require.</p>

<table class="info">
	<tr>
		<th>idperson</th>
		<th>idpartner</th>
		<th>idmother</th>
		<th>idfather</th>
		<th>dag</th>
		<th>IsInEduc</th>
		<th>il_earns</th>
		<th>il_Means Test</th>
		<th>il_Means Test upd.</th>
		<th>family_sl</th>
		<th>family_sl updated</th>
		<th>bsa_s not updated</th>
		<th>bsa_s updated</th>
	</tr>
	<tr>
		<td>101</td>
		<td>102</td>
		<td>0</td>
		<td>0</td>
		<td>45</td>
		<td>0</td>
		<td>1000</td>
		<td>1000</td>
		<td>1000</td>
		<td>A</td>
		<td>A</td>
		<td>700</td>
		<td>600</td>
	</tr>
	<tr>
		<td>102</td>
		<td>101</td>
		<td>0</td>
		<td>0</td>
		<td>40</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>A</td>
		<td>A</td>
		<td>0</td>
		<td>0</td>
	</tr>
	<tr>
		<td>103</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>18</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>600</td>
		<td>A</td>
		<td>B</td>
		<td>0</td>
		<td>1000</td>
	</tr>
	<tr>
		<td>103</td>
		<td>0</td>
		<td>102</td>
		<td>101</td>
		<td>10</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>A</td>
		<td>A</td>
		<td>0</td>
		<td>0</td>
	</tr>
</table>

<p>The last two columns of the table
show that there is a considerable difference in social assistance depending on
whether the units are updated or not before calculating this benefit. This is
caused by the 18-year-old student receiving the education benefit, which is
part of the means test of the dependent child condition. As the education
benefit is however calculated after the first use of the assessment unit family_sl in the child benefit, the 18 year old is
initially identified as dependent child and belongs to the unit of her/his
parents. Only if the function UpdateTU is used to
update the units, she/he forms her/his own unit for the social assistance
benefit.</p>

<h4>Excursus: using footnote parameters to change the assessment unit of operands</h4>

<p>Section <a href="EM_FC_FootnoteParameters.htm">EUROMOD Functions - Footnote parameters for
the further specification of operands</a> explains how to change the level of
assessment for single operands of a formula or a condition. A special rule must
be taken into account when this possibility is used, which is explained here and not before, as the knowledge imparted in the current
section is of advantage in understanding the rule. Moreover, though more
advanced users definitely should be aware of it, the rule better fits in an
excursus, as it is a bit challenging. The rule reads: <strong>the assessment unit of the operand must </strong>&quot;<strong>contain</strong>&quot;<strong> the assessment
unit of the function</strong>. Consider the following examples to understand this
&quot;container rule&quot;.</p>

<table class="spine">
	<caption>Example 14:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>ArithOp</td>
		<td class="on">on</td>
		<td>workable example</td>
	</tr>
	<tr>
		<td>formula</td>
		<td>500#m – yem#1</td>
		<td></td>
	</tr>
	<tr>
		<td>#1_level</td>
		<td>household_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>lowlim</td>
		<td>0</td>
		<td></td>
	</tr>
	<tr>
		<td>output_var</td>
		<td>sin02_s</td>
		<td></td>
	</tr>
	<tr>
		<td>TAX_UNIT</td>
		<td>family_sl</td>
		<td></td>
	</tr>
	<tr class="function">
		<td>ArithOp</td>
		<td class="on">on</td>
		<td>not workable example</td>
	</tr>
	<tr>
		<td>formula</td>
		<td>500#m – yem#1</td>
		<td></td>
	</tr>
	<tr>
		<td>#1_level</td>
		<td>family_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>lowlim</td>
		<td>0</td>
		<td></td>
	</tr>
	<tr>
		<td>output_var</td>
		<td>sin02_s</td>
		<td></td>
	</tr>
	<tr>
		<td>TAX_UNIT</td>
		<td>household_sl</td>
		<td></td>
	</tr>
</table>

<p>The first function is workable (though one could question its sense).
The function’s assessment unit is the family, while the assessment unit of the
operand yem is changed to household. Households without
question contain (one or more) families. Thus each family receives 500 Euro
minus all employment income received by anyone in the household (containing the
respective family). The second function puts things the other way round. The
function’s assessment unit is the household, while the assessment unit of the
operand yem is the family. What would this mean?
Each household receives 500 Euro minus the employment income of which family
within this household? Please note, that a violation of the container rule
leads to an error message.<a href="#_ftn7" name="_ftnref7" title="">[7]</a></p>

<p>For the
sake of order, a rule needs an exception. The exception for the container rule
concerns operands in conditions. They can be changed to any assessment unit.
Example 15 illustrates why.</p>

<table class="spine">
	<caption>Example 15:</caption>
	<tr class="policy">
		<td>Policy</td>
		<td>Grp/No</td>
		<td class="system">SL_demo</td>
		<td>Comment</td>
	</tr>
	<tr class="function">
		<td>Elig</td>
		<td></td>
		<td class="on">on</td>
		<td></td>
	</tr>
	<tr>
		<td>condition</td>
		<td></td>
		<td>dag&lt;50 &amp; yem&lt;1500#m &amp; poa#1=0</td>
		<td></td>
	</tr>
	<tr>
		<td>#_level</td>
		<td>1</td>
		<td>household_sl</td>
		<td></td>
	</tr>
	<tr>
		<td>TAX_UNIT</td>
		<td></td>
		<td>family_sl</td>
		<td></td>
	</tr>
</table>


<p>In the example a household member becomes eligible if she/he is younger than 50, the employment income of her/his family does not exceed 1,500 Euro monthly, and nobody within the household she/he lives in receives old age pension. The formulation &quot;a household member becomes eligible&quot; instead of &quot;the household becomes eligible&quot; already provides a hint for the rational of the condition exception. In fact conditions are always evaluated on individual level, any assessment unit level condition just means that all individuals within the assessment unit fulfils the condition. That means, on closer examination, the condition exception is not really an exception, as one always changes the assessment level from individual to some other unit that necessarily must contain the individual as the smallest unit.</p>

<p>&nbsp;</p>

</div>

<div>

<hr align=left size=1 width="33%">

<p class="footnote"><a href="#_ftnref1" name="_ftn1" title="">[1]</a> A rather special case should be mentioned in this context. If an assessment unit is used with the parameter <i>#i_level</i>, assessment unit formation only takes place if the function is carried out for at least one unit. That means if no unit is ‘eligible’ (parameter <i>who_must_be_elig</i>) the assessment unit is not formed.</p>

<p class="footnote"><a href="#_ftnref2" name="_ftn2" title="">[2]</a> Please note, that the notation A,B,…,F just serves explanation purposes and is not really used by the model. See section <a href="EM_FC_DefOutput.htm">EUROMOD Functions - The system function DefOutput</a>, unitinfo parameters, for the possibility of putting out assessment unit settings.</p>

<p class="footnote"><a href="#_ftnref3" name="_ftn3" title="">[3]</a> Note, that the list indicates the order in which the <u>model</u> operates the conditions, but not the order in which the parameters should be defined, i.e. it is for example no problem to define the parameter DepPartnerCond before the parameter DepChildCond.</p>

<p class="footnote"><a href="#_ftnref4" name="_ftn4" title="">[4]</a> Respectively with respect to the variable idparent, if this variable is used in the dataset instead of idmother and idfather.</p>

<p class="footnote"><a href="#_ftnref5" name="_ftn5" title="">[5]</a> Respectively with respect to the variable idparent, if this variable is used in the dataset instead of idmother and idfather. In this case also a person is a dependent parent, whose partner (with respect to variable idpartner) is the parent of the head or her/his partner. The latter takes into account, that only one parent can be defined by the variable idparent and assumes that this parent’s partner is the other parent.</p>

<p class="footnote"><a href="#_ftnref6" name="_ftn6" title="">[6]</a> Respectively with respect to the variable idparent, if this variable is used in the dataset instead of idmother and idfather.</p>

<p class="footnote"><a href="#_ftnref7" name="_ftn7" title="">[7]</a> To complicate things a bit further, individual assessment units are exempted from the container rule as another rule applies: the individual within the unit to be taken into account is the head. With this information the second function of the example would read as follows, if the parameter <i>#1_level</i> was set to <i>individual_sl</i>: each household receives 500 Euro minus the employment income of the head. To your relief, this exemption is nearly ever applicable and just mentioned as a warning, as such (usually intransparent or even wrong) modelling does not lead to an error message. The reason for the exception is of technical nature, as it allows for the following (sensible) exception with respect to conditions.</p>

</div>

</body>

</html>
