#ifndef EMCONTROL
#define EMCONTROL

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <time.h>
#include "tinyxml.h"
#include "EMSystem.h"
#include "EMTaxUnit.h"
#include "EMUtilities.h"
#include "EMTable.h"

//type definitions
typedef std::vector<CEMSystem> SystemContainer_t;
typedef std::map<std::string, CEMVar> Vardesc_t;
typedef std::vector<CEMVar> VardescV_t;

//types of variables (used for GetVarIndex)
#define VARTYPE_DEFAULT	-1 //variable generated by CreateDefaultVariables
#define VARTYPE_DATA	0 //data variable
#define VARTYPE_DESC	1 //non-data standard variable described in variables.xls
#define VARTYPE_DERDESC	2 //non-data variable derived from a standard variable described in variables.xls (e.g. yem_bkup)
#define VARTYPE_NONDESC	3 //non-data variable not described in variables.xls (variables generated by func_loop, func_unitloop, func_totals, func_defvar, func_defconst)
#define CREATE_NOT		0 //do not create variable (only return index)
#define CREATE_PARAM	1 //variable is created due to a call from Prepare (VarParam, VarILParam, FormOp)
#define CREATE_INTERNAL	2 //variable is created internally (not because of usage in parameter file)

//forward declaration
class CEMXML;

struct CTimeRec
{
	std::string Action;
	std::string Actor;
	int Duration;
};
typedef std::vector<CTimeRec> TimeRec_t;

struct AddOnEntry {
	std::string m_Ident;
	std::string m_Pos;
	bool m_Before;
	std::string m_FuncDefPol;
	std::vector<std::string> m_ParNames;
	std::vector<std::string> m_ParVals;
	std::vector<std::string> m_ParIds;
	unsigned int m_Row;
	AddOnEntry() { m_Ident=m_Pos=m_FuncDefPol=""; m_Before=0; m_ParNames.empty(); m_ParVals.empty(); }
};
typedef std::vector<AddOnEntry> AddOnEntryContainer_t;

struct AddOnSys {
	struct AddOn *m_AddOn;
	std::string m_Name;
	unsigned int m_Col;
	AddOnEntryContainer_t m_Pols;
	AddOnEntryContainer_t m_Funcs;
	AddOnEntryContainer_t m_Pars;
	AddOnSys() { m_AddOn=NULL; m_Name=""; m_Col=0; m_Pols.clear(); m_Funcs.clear(); m_Pars.clear(); }
};
typedef std::vector<AddOnSys> AddOnSysContainer_t;

struct AddOn {
	std::string m_ControlName; //name of addon-control txt-file (sheet 'aocontrol_x' in parameter file)
	unsigned int m_FirstSystemCol; //column with label 'first_system'
	unsigned int m_EndSystemCol; //column with label 'end_system'
	unsigned int m_ParamNameCol; //column with label 'param_name'
	unsigned int m_ParamIdCol; //column with label 'period'
	AddOnSysContainer_t m_Systems;
	AddOn() { m_ControlName=""; m_FirstSystemCol=m_EndSystemCol=m_ParamNameCol=m_ParamIdCol=0; m_Systems.clear(); }
};
typedef std::vector<AddOn> AddOnContainer_t;

struct UpratingIndex {
	int m_VarIndex;
	std::map<std::string, double> m_YearValues;
};

class CEMControl {
public:
	//constructor/descructor
	CEMControl();
	~CEMControl();

	//variables ...
	//... storing information coming from config file
	std::string m_ConfigName; //name and path of config file
	std::string m_EMVersion; //EUROMOD version number
	std::string m_ExeVersion; //EUROMOD executable version number (not used anymore since UI and executable form one software bundle)
	std::string m_UIVersion; //EUROMOD user-interface version number
	std::string m_ParamPath; //path to input parameter files (i.e. sheet of parameter file in txt-format)
	std::string m_ConfigPath; //path to configuration files (only XML: VarConfig.xml)
	std::string m_EMContentPath; //path to whole EUROMOD file structure
	std::string m_OutputPath; //path to write output
	std::string m_DataPath; //path to input dataset
	std::string m_DataSet; //name of input dataset
	std::string m_DataSetId; //unique identifier of input dataset
	std::string m_HeaderDate; //date for file with output-information (EM-Version, date, etc.)
	std::string m_OutfileDate; //date to append to output file names (usually empty)
	std::string m_ControlName; //name of control txt-file (sheet 'control' in parameter file)
	std::string m_DataConfig; CEMXML DataConfigXML; //only XML: name of file with data configuration
	std::string m_SpineName; //name of spine txt-file (sheet 'spine' in parameter file)
	std::string m_ErrLogFile; //path and name of error logfile
	int m_LogWarnings; //yes: log warnings instead of stopping program
	int m_LogRunTime; //yes: produce detailed logfile with respect to runtime
	int m_IsPublicVersion; //yes: model run was started via a EUROMOD public version (used for deactivating private policies)
	int m_LastRun; //yes: there are no subsequent runs triggered by the run tool
	static int m_InputTXT; //parameter input is stored in ... yes: text files, no: XML files
	std::string m_AOParamPath; //path to add-on input parameter files

	//... storing information coming from parameter sheet control
	std::string m_Country; //country acronym (e.g. ee for estonia)
	int m_DataCurrencyEuro; //currency used in dataset; true if euro; false if national
	std::string m_UseDefault; //use default values stored in variables.txt or defined by func_setdefault if variable not found in dataset
	double m_UseCommonDefault; //false: do not use default values in variables.txt if a func_setdefault exists
	double m_DataIncomeYear; //income year of the dataset (used for query GetDataIncomeYear)
	double m_StartHHID; //ID of a special household to start with; 0 to start from first hh in dataset
	double m_LastHHID;  //ID of a special household to stop with; 0 to stop with last hh in the dataset
	std::vector<std::vector<std::string> > m_PolicySwitches; //switchable policies' redefined switches	// please retain the space in "> >" to avoid compiler errors in Linux
	double m_IgnorePrivate; //July 2016: new option for running only public components
	long m_FirstNHHOnly;
	double m_ReadXVariables; //if true expenditure variables (x#) are read, even if they are not defined in the variables file

	//... storing main structures
	SystemContainer_t m_Systems; //structure storing systems to run

	//... storing add-ons
	AddOnContainer_t m_AddOns;

	//... for miscellaneous use
	Vardesc_t m_VarIndex; //structure storing variable descriptions (for used variables)
	VardescV_t m_VarIndexV; //storing the same information as m_VarIndex but in the same order as variables are stored in the HH structure of EMSystem
	Vardesc_t m_Vardesc; //structure storing all variable descriptions (from variables.txt)
	TimeRec_t m_TimeRec; //structure storing program run time
	time_t m_StartTime; //storing data and time of program start
	bool m_RunTime; //1 if program is in "run-time" (for error log)
	bool m_SimInfoAvailable; //if variables.xls still contains _s variables and column 'model generated' 1 else 0
	
	//indexes to commonly used variable (most frequent in functions)
	int m_ivPID;
	int m_ivHHID;
	int m_ivPartnerID;
	int m_ivParentID;
	int m_ivMotherID;
	int m_ivFatherID;
	int m_ivAge;
	int m_ivElig;
	int m_ivMaritStat;
	int m_ivLabSupStat;
	int m_ivEducStat;
	int m_ivDisab;
	int m_ivOcc;
	int m_ivCivilServ;
	int m_ivInternal1;
	int m_ivInternal2;

	//functions
	bool GoAhead(std::string ConfigName);	//kick off all operations
	bool GetVarIndex(std::string VarName, int &VarIndex, int CreateType=CREATE_NOT, int VarType=VARTYPE_DESC, int Monetary=-1, int IsGlobal=-1, int SumTU=-1); //return index of variable in variable vectors
	bool GetDefaultValues(); //not used anymore, replaced by ...
	bool CreateDefaultVariables();
	void AddTimeRec(std::string Action,	std::string Actor, int Duration, size_t At=9999);

	//input tables are administrated in control, as several systems may use one input table
	CEMTable *GetInputTable(std::string path, std::string file, bool useIfExists, std::string systemName, int viRowMergeVar, int ignoreNRows,
		int ignoreNCols, std::string decSep, std::string repByEMPath, double defaultValue, bool doRanges, bool lookUpMode);
	void ReleaseInputTable(CEMTable *table);

	std::string GetSystemPolicySwitchesForHeader(std::string SystemID);

	//for providing the config-params via the command-line instead of the config-file
	void TakeConfigParam(std::string projectPath, std::string systemName, std::string dataName, std::string dataPath, std::string outputPath);

private:
	//variables
	//... for parameter file reading
	unsigned int m_FirstSystemCol; //column with label 'first_system'
	unsigned int m_EndSystemCol; //column with label 'end_system'
	unsigned int m_ParamNameCol; //column with label 'param_name'
	unsigned int m_ParamIdCol; //column with label 'period'
	bool m_CommandLineConfig; //config-params are provided via the command-line instead of the config-file
	std::string m_ExchangeRateDate; //user-interface option: output-in-euro allows for selection of exchange-rate (june 30, year average, 1st or 2nd semester)
	
	//functions
	bool ReadInput(); //data and parameter reading: ...
	bool TXT_ReadInput_Config(); bool XML_ReadInput_Config();
	bool TXT_ReadInput_Param(); bool XML_ReadInput_Param();
	bool TXT_ReadVardesc(); bool XML_ReadVardesc(); //... read variable definitions from variables.txt
	bool ReadData(); // ... read input data
	bool TXT_ReadConfigParam(); //... read parameters from config file
	bool CheckConfigParam(); bool XML_ReadConfigParam(); //... check whether config parameters are ok
	bool TXT_ReadControlParam(); bool XML_ReadControlParam(); //... read parameters from control parameter sheet
	bool TXT_ReadSpineParam(); //... read parameters from spine parameter sheet
	bool TXT_ReadPolicyParam(); //... read parameters from policy parameter sheets
	bool CheckParam(); //... check if all necessary parameters are indicated
	bool AssessGenVarInd(); //asses indexes of generally used variables
	bool CheckParSheetFormat(std::vector<std::string> tokline, std::string sheet, //...check if labels and systems in parameter sheets are were they supposed to be
		unsigned int FirstSystemCol=0, unsigned int EndSystemCol=0, unsigned int ParamNameCol=0, unsigned int ParamIdCol=0, unsigned int SysColumn=0, std::string SysName="");
	bool Run(); //kicks off all calculations
	void LogRunTime();
	bool TXT_ReadAOControlParam(); //read add-on parameters
	bool TXT_ReadAOParam();
	bool TXT_ReadAOPolicyParam(std::string PolName, AddOnSys *AOSys, CEMSystem *Sys, unsigned int pnum, int fInd=-1);
	CEMXML *XML_ReadInput_GetReferencePolicy(std::string RefPol, std::map<int, CEMXML*>PolOrder);

	std::vector<CEMTable*>m_InputTables;

	std::string AdaptSwitchIfSwitchablePolicy(std::string SystemID, std::string PolicyName, std::string CurrentSwitch);
	bool ReadGlobalConfig(); bool ReadHICPConfig(); bool ReadExchangeRatesConfig();
	bool ReadUpratingIndices(CEMXML *xml);
	void SetUpratingIndices(CEMSystem *sys);
	std::vector<UpratingIndex> m_UpratingIndices;
};

#endif
