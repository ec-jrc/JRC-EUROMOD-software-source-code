using EM_Common;
using EM_Crypt;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;


namespace EM_Executable
{
    internal partial class HHAdmin
    {
        /// <summary>
        /// read data from file and create the complete list of variables for each person (HH.personVarList),
        /// i.e. also for non-data variables (simulated, created by DefVar, loop-counters, ...)
        /// note that HHAdmin and OperandAmin need to "talk" a bit here:
        /// e.g. OperandAdmin tells HHAdmin what to read (incl. vars that may be provided by SetDefault); HHAdmin reports back what he read
        /// </summary>
        internal void GenerateData()
        {
            string path = GetDataPath(infoStore);

            try // note: maybe the extra try/catch is disputable (i.e. one could rely on general try/catch as all other functions instead)
            {   // but IO-problems seem more likely and serious and this may help to better locate the error
                IEnumerable<string> inputLines = null;
                if (infoStore.hasData())
                {
                    inputLines = infoStore.inputData.Skip(1);
                }
                else
                {
                    if (!string.IsNullOrEmpty(infoStore.runConfig.dataPassword))
                    {
                        byte[] allBytes = File.ReadAllBytes(path);
                        if (SimpleCrypt.IsEncrypted(allBytes))
                            allBytes = SimpleCrypt.SimpleDecryptWithPassword(allBytes, infoStore.runConfig.dataPassword, SimpleCrypt.EUROMOD_ENCRYPTED_STRING.Length);
                        if (allBytes == null)
                        {
                            infoStore.communicator.ReportError(new Communicator.ErrorInfo() { isWarning = false, message = $"Wrong decryption password!" });
                            return;
                        }
                        inputLines = System.Text.Encoding.Default.GetString(allBytes).Split(Environment.NewLine.ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                    }
                    else
                    {
                        inputLines = File.ReadLines(path);
                    }
                }

                // first split header line to get the column-indices of the variables to read
                Dictionary<string, int> varColumn = new Dictionary<string, int>();
                Dictionary<string, int> stringVarColumn = new Dictionary<string, int>();

                // check if all variables exist
                List<string> missing = new List<string>(); string missingStringVar = string.Empty;
                foreach (var readVar in infoStore.operandAdmin.GetVarsToRead()) // the numeric (i.e. usual) variables
                {
                    if (infoStore.allDataVariables.Contains(readVar)) // data contains the variable
                    {
                        varColumn.Add(readVar, infoStore.allDataVariables.IndexOf(readVar));
                        infoStore.operandAdmin.SetProvidedBySetDefault(readVar, false); // "inform" any possible SetDefault that 
                    }                                                                   // it does not have to provide a value
                    else // data does not contain the variable
                    {
                        if (!infoStore.operandAdmin.IsProvidedByDefault(readVar, infoStore.country.data.useCommonDefault)) missing.Add(readVar);
                        // else will be initialised by SetDefault
                    }
                }
                foreach (string stringVar in infoStore.operandAdmin.indexStringVars.Keys) // possible (rather unusual) string variables
                {
                    if (infoStore.allDataVariables.Contains(stringVar)) stringVarColumn.Add(stringVar, infoStore.allDataVariables.IndexOf(stringVar));
                    else missingStringVar += stringVar + ", ";
                }

                if (missingStringVar != string.Empty)
                {
                    infoStore.communicator.ReportError(new Communicator.ErrorInfo() { isWarning = true,
                        message = $"{path}: String-variable(s) {missingStringVar.TrimEnd(new char[] { ',', ' ' })} not found (thus cannot be outputted)" });
                }

                // get non-data variables from the OperandAdmin, i.e. simulated vars, vars generated by DefVar, by default, loop-counters, ...
                // as they also need to be added to the persons' variables list, see below
                List<string> nonDataVars = infoStore.operandAdmin.GetPersonVarsNotRead();

                if (missing.Count > 0)
                {
                    string sMissing = string.Empty;  foreach (string m in missing) { nonDataVars.Add(m); sMissing += m + ", "; }
                    infoStore.communicator.ReportError(new Communicator.ErrorInfo() { isWarning = true,
                        message = $"{path}: Variable(s) {sMissing.TrimEnd(new char[] { ',', ' ' })} not found (zero is used as default)" });
                }

                // assess the column-index of the idHH variable
                string IDHH = DefVarName.IDHH;
                int indexIDHH; if (varColumn.ContainsKey(IDHH)) indexIDHH = indexIDHH = varColumn[IDHH];
                else throw new Exception($"Variable {IDHH} not found");

                double? firstHH = infoStore.runConfig.firstHH, lastHH = infoStore.runConfig.lastHH;
                double nHHOnly = infoStore.runConfig.nHHOnly, nHHRead = 0;

                // generate the (complete) variables-list for each person in each HH
                hhs = new List<HH>(); Dictionary<string, HH> indexReadHH = new Dictionary<string, HH>();
                double biggestIDHH = double.MinValue; // use to check for idhh ordering in dataset
                foreach (string inputLine in inputLines.Skip(1))
                {
                    if (inputLine == string.Empty) continue;
                    string[] splitInputLine = inputLine.Split('\t');
                    // check if dataset is ordered by idhh
                    if (double.Parse(splitInputLine[indexIDHH]) < biggestIDHH)
                        infoStore.communicator.ReportError(new Communicator.ErrorInfo() { isWarning = false,
                            message = $"{path}: dataset is not sorted by household!" });

                    HH currentHH;
                    if (!indexReadHH.ContainsKey(splitInputLine[indexIDHH]))
                    {
                        biggestIDHH = double.Parse(splitInputLine[indexIDHH]); // get the latest idhh
                        currentHH = new HH(infoStore);

                        if (firstHH != null && double.TryParse(splitInputLine[indexIDHH], out double fhhid) && fhhid < firstHH) continue;
                        if (lastHH != null && double.TryParse(splitInputLine[indexIDHH], out double lhhid) && lhhid > lastHH) break;
                        if (++nHHRead > nHHOnly) break;

                        hhs.Add(currentHH); indexReadHH.Add(splitInputLine[indexIDHH], currentHH);
                    }
                    else currentHH = indexReadHH[splitInputLine[indexIDHH]];

                    // first get (numeric) data variables for the person ...
                    List<double> onePersonsVariables = new List<double>(varColumn.Count);
                    foreach (var vc in varColumn.Values)
                    {
                        if (!double.TryParse(EM_Helpers.AdaptDecimalSign(splitInputLine[vc]), out double number))
                            throw new Exception($"Variable {(from v in varColumn where v.Value == vc select v.Key).FirstOrDefault()}: failed converting '{splitInputLine[vc]}' to number");
                        onePersonsVariables.Add(number);
                    }

                    // ... then add 0 for each non-data variable ...
                    for (int ndv = 0; ndv < nonDataVars.Count; ++ndv) onePersonsVariables.Add(0);

                    // ... finally get (rather unusual) non-numeric data variables
                    List<string> onePersonsStringVariables = new List<string>(stringVarColumn.Count);
                    foreach (var svc in stringVarColumn.Values) onePersonsStringVariables.Add(splitInputLine[svc]);

                    currentHH.personVarList.Add(onePersonsVariables);
                    currentHH.personStringVarList.Add(onePersonsStringVariables);
                }

                if (hhs.Count == 0) throw new Exception("No housholds could be read");

                // "inform" the OperandAdmin about the final variable-index in the HH.personVarList
                int c = 0; Dictionary<string, int> varIndex = new Dictionary<string, int>(), stringVarIndex = new Dictionary<string, int>();
                foreach (var vi in varColumn) varIndex.Add(vi.Key, c++);
                foreach (string v in nonDataVars) varIndex.Add(v, c++);
                c = 0; foreach (var vi in stringVarColumn) stringVarIndex.Add(vi.Key, c++);
                infoStore.operandAdmin.SetVarIndex(varIndex, stringVarIndex);

                // each HH has a dummy individual TU (for usage by spine-functions which do not have a TAX_UNIT parameter
                // (see CreateDummyTU-function for further comments)
                infoStore.indexTUs.Add(DUMMY_INDIVIDUAL_TU, null);
                foreach (HH hh in hhs) CreateDummyTU(hh);

#if OLD_EXE_COMPARISON
                SimulateOldExeRand();
#endif
            }
            catch (Exception exception)
            {
                throw new Exception($"Failed reading file {path}{Environment.NewLine}{exception.Message}");
            }
        }

        private static string GetDataPath(InfoStore infoStore)
        {
            return Path.Combine(infoStore.country.data.specialPath ?? infoStore.runConfig.pathData,
                                infoStore.country.data.Name);
        }

        internal static void GetAllDataVariables(InfoStore infoStore)
        {
            string path = string.Empty;
            try
            {
                string firstLine = null;

                if (infoStore.hasData())
                {
                    firstLine = infoStore.inputData.First();
                }
                else
                {
                    path = GetDataPath(infoStore);

                    if (!string.IsNullOrEmpty(infoStore.runConfig.dataPassword))
                    {
                        byte[] allBytes = File.ReadAllBytes(path);
                        if (SimpleCrypt.IsEncrypted(allBytes))
                            allBytes = SimpleCrypt.SimpleDecryptWithPassword(allBytes, infoStore.runConfig.dataPassword, SimpleCrypt.EUROMOD_ENCRYPTED_STRING.Length);
                        if (allBytes == null)
                        {
                            infoStore.communicator.ReportError(new Communicator.ErrorInfo() { isWarning = false, message = $"Wrong decryption password!" });
                            return;
                        }
                        firstLine = System.Text.Encoding.Default.GetString(allBytes).Split(Environment.NewLine.ToCharArray(), StringSplitOptions.RemoveEmptyEntries).First();
                    }
                    else
                    {
                        firstLine = File.ReadLines(path).First();
                    }
                }

                // a very basic check ...
                if (!firstLine.Contains('\t')) throw new Exception("Data seem to be not tab-delimited");

                infoStore.allDataVariables.Clear();
                foreach (string v in firstLine.ToLower().Split('\t')) infoStore.allDataVariables.Add(v.Trim());

                // ... and another
                if (!infoStore.allDataVariables.Contains(DefVarName.IDHH)) throw new Exception($"Data do not contain essential variable {DefVarName.IDHH}"); ;
            }
            catch (Exception exception)
            {
                throw new Exception($"Failed reading file {path}{Environment.NewLine}{exception.Message}");
            }
        }

#if OLD_EXE_COMPARISON
        // This method is meant to simulate the same random numbers that the old executable produced, by reading pre-compiled lists of random numbers from text files.
        // It was introduced only for a short testing period to validate the results of the EM3 executable against EM2, and only worked for some baselines.
        private void SimulateOldExeRand()
        {
            List<double> randList = new List<double>();
            string seed = null;
            try
            {
                switch (infoStore.country.cao.shortName.ToUpper())
                {
                    case "BE": case "CY": case "DK": case "SK": case "CC": seed = "rand_seed1.txt"; break;
                    case "HU": case "UK": seed = "rand_seed2.txt"; break;
                    case "EL": case "IE": case "PT": seed = "rand_seed5.txt"; break;
                    case "AT": seed = "rand_seed152331.txt"; break;
                    case "FR": seed = "rand_seed3579.txt"; break;
                }
                if (infoStore.country.sys.name.ToLower() == "uk_2005") seed = "rand_seed1.txt"; // for 2005 it's 1, for all other years 2

                if (seed == null) return;

                string path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData), "EUROMOD", "EM3Test");
                foreach (string line in File.ReadLines(Path.Combine(path, seed)))
                    randList.Add(double.Parse(line));

                int index = 0;
                foreach (HH hh in hhs) hh.TakeOldExeRand(randList, ref index);
            }
            catch
            {
                infoStore.communicator.ReportError(new Communicator.ErrorInfo() { isWarning = true,
                    message = "Simulating the old executabel's random number approach failed - old/new results are not comparable" });
            }
        }
#endif
    }
}
